/*
 * Copyright (c) 2016, Alliance for Open Media. All rights reserved
 *
 * This source code is subject to the terms of the BSD 2 Clause License and
 * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
 * was not distributed with this source code in the LICENSE file, you can
 * obtain it at www.aomedia.org/license/software. If the Alliance for Open
 * Media Patent License 1.0 was not distributed with this source code in the
 * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
 */

#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config/aom_config.h"

#include "aom_dsp/aom_dsp_common.h"
#include "aom_ports/mem.h"
#include "aom_scale/aom_scale.h"
#include "av1/common/common.h"
#include "av1/common/resize.h"

#include "config/aom_scale_rtcd.h"

// Filters for interpolation (0.5-band) - note this also filters integer pels.
static const InterpKernel filteredinterp_filters500[(1 << RS_SUBPEL_BITS)] = {
  { -3, 0, 35, 64, 35, 0, -3, 0 },    { -3, 0, 34, 64, 36, 0, -3, 0 },
  { -3, -1, 34, 64, 36, 1, -3, 0 },   { -3, -1, 33, 64, 37, 1, -3, 0 },
  { -3, -1, 32, 64, 38, 1, -3, 0 },   { -3, -1, 31, 64, 39, 1, -3, 0 },
  { -3, -1, 31, 63, 39, 2, -3, 0 },   { -2, -2, 30, 63, 40, 2, -3, 0 },
  { -2, -2, 29, 63, 41, 2, -3, 0 },   { -2, -2, 29, 63, 41, 3, -4, 0 },
  { -2, -2, 28, 63, 42, 3, -4, 0 },   { -2, -2, 27, 63, 43, 3, -4, 0 },
  { -2, -3, 27, 63, 43, 4, -4, 0 },   { -2, -3, 26, 62, 44, 5, -4, 0 },
  { -2, -3, 25, 62, 45, 5, -4, 0 },   { -2, -3, 25, 62, 45, 5, -4, 0 },
  { -2, -3, 24, 62, 46, 5, -4, 0 },   { -2, -3, 23, 61, 47, 6, -4, 0 },
  { -2, -3, 23, 61, 47, 6, -4, 0 },   { -2, -3, 22, 61, 48, 7, -4, -1 },
  { -2, -3, 21, 60, 49, 7, -4, 0 },   { -1, -4, 20, 60, 49, 8, -4, 0 },
  { -1, -4, 20, 60, 50, 8, -4, -1 },  { -1, -4, 19, 59, 51, 9, -4, -1 },
  { -1, -4, 19, 59, 51, 9, -4, -1 },  { -1, -4, 18, 58, 52, 10, -4, -1 },
  { -1, -4, 17, 58, 52, 11, -4, -1 }, { -1, -4, 16, 58, 53, 11, -4, -1 },
  { -1, -4, 16, 57, 53, 12, -4, -1 }, { -1, -4, 15, 57, 54, 12, -4, -1 },
  { -1, -4, 15, 56, 54, 13, -4, -1 }, { -1, -4, 14, 56, 55, 13, -4, -1 },
  { -1, -4, 14, 55, 55, 14, -4, -1 }, { -1, -4, 13, 55, 56, 14, -4, -1 },
  { -1, -4, 13, 54, 56, 15, -4, -1 }, { -1, -4, 12, 54, 57, 15, -4, -1 },
  { -1, -4, 12, 53, 57, 16, -4, -1 }, { -1, -4, 11, 53, 58, 16, -4, -1 },
  { -1, -4, 11, 52, 58, 17, -4, -1 }, { -1, -4, 10, 52, 58, 18, -4, -1 },
  { -1, -4, 9, 51, 59, 19, -4, -1 },  { -1, -4, 9, 51, 59, 19, -4, -1 },
  { -1, -4, 8, 50, 60, 20, -4, -1 },  { 0, -4, 8, 49, 60, 20, -4, -1 },
  { 0, -4, 7, 49, 60, 21, -3, -2 },   { -1, -4, 7, 48, 61, 22, -3, -2 },
  { 0, -4, 6, 47, 61, 23, -3, -2 },   { 0, -4, 6, 47, 61, 23, -3, -2 },
  { 0, -4, 5, 46, 62, 24, -3, -2 },   { 0, -4, 5, 45, 62, 25, -3, -2 },
  { 0, -4, 5, 45, 62, 25, -3, -2 },   { 0, -4, 5, 44, 62, 26, -3, -2 },
  { 0, -4, 4, 43, 63, 27, -3, -2 },   { 0, -4, 3, 43, 63, 27, -2, -2 },
  { 0, -4, 3, 42, 63, 28, -2, -2 },   { 0, -4, 3, 41, 63, 29, -2, -2 },
  { 0, -3, 2, 41, 63, 29, -2, -2 },   { 0, -3, 2, 40, 63, 30, -2, -2 },
  { 0, -3, 2, 39, 63, 31, -1, -3 },   { 0, -3, 1, 39, 64, 31, -1, -3 },
  { 0, -3, 1, 38, 64, 32, -1, -3 },   { 0, -3, 1, 37, 64, 33, -1, -3 },
  { 0, -3, 1, 36, 64, 34, -1, -3 },   { 0, -3, 0, 36, 64, 34, 0, -3 },
};

// Filters for interpolation (0.625-band) - note this also filters integer pels.
static const InterpKernel filteredinterp_filters625[(1 << RS_SUBPEL_BITS)] = {
  { -1, -8, 33, 80, 33, -8, -1, 0 }, { -1, -8, 31, 80, 34, -8, -1, 1 },
  { -1, -8, 30, 80, 35, -8, -1, 1 }, { -1, -8, 29, 80, 36, -7, -2, 1 },
  { -1, -8, 28, 80, 37, -7, -2, 1 }, { -1, -8, 27, 80, 38, -7, -2, 1 },
  { 0, -8, 26, 79, 39, -7, -2, 1 },  { 0, -8, 25, 79, 40, -7, -2, 1 },
  { 0, -8, 24, 79, 41, -7, -2, 1 },  { 0, -8, 23, 78, 42, -6, -2, 1 },
  { 0, -8, 22, 78, 43, -6, -2, 1 },  { 0, -8, 21, 78, 44, -6, -2, 1 },
  { 0, -8, 20, 78, 45, -5, -3, 1 },  { 0, -8, 19, 77, 47, -5, -3, 1 },
  { 0, -8, 18, 77, 48, -5, -3, 1 },  { 0, -8, 17, 77, 49, -5, -3, 1 },
  { 0, -8, 16, 76, 50, -4, -3, 1 },  { 0, -8, 15, 76, 51, -4, -3, 1 },
  { 0, -8, 15, 75, 52, -3, -4, 1 },  { 0, -7, 14, 74, 53, -3, -4, 1 },
  { 0, -7, 13, 74, 54, -3, -4, 1 },  { 0, -7, 12, 73, 55, -2, -4, 1 },
  { 0, -7, 11, 73, 56, -2, -4, 1 },  { 0, -7, 10, 72, 57, -1, -4, 1 },
  { 1, -7, 10, 71, 58, -1, -5, 1 },  { 0, -7, 9, 71, 59, 0, -5, 1 },
  { 1, -7, 8, 70, 60, 0, -5, 1 },    { 1, -7, 7, 69, 61, 1, -5, 1 },
  { 1, -6, 6, 68, 62, 1, -5, 1 },    { 0, -6, 6, 68, 62, 2, -5, 1 },
  { 1, -6, 5, 67, 63, 2, -5, 1 },    { 1, -6, 5, 66, 64, 3, -6, 1 },
  { 1, -6, 4, 65, 65, 4, -6, 1 },    { 1, -6, 3, 64, 66, 5, -6, 1 },
  { 1, -5, 2, 63, 67, 5, -6, 1 },    { 1, -5, 2, 62, 68, 6, -6, 0 },
  { 1, -5, 1, 62, 68, 6, -6, 1 },    { 1, -5, 1, 61, 69, 7, -7, 1 },
  { 1, -5, 0, 60, 70, 8, -7, 1 },    { 1, -5, 0, 59, 71, 9, -7, 0 },
  { 1, -5, -1, 58, 71, 10, -7, 1 },  { 1, -4, -1, 57, 72, 10, -7, 0 },
  { 1, -4, -2, 56, 73, 11, -7, 0 },  { 1, -4, -2, 55, 73, 12, -7, 0 },
  { 1, -4, -3, 54, 74, 13, -7, 0 },  { 1, -4, -3, 53, 74, 14, -7, 0 },
  { 1, -4, -3, 52, 75, 15, -8, 0 },  { 1, -3, -4, 51, 76, 15, -8, 0 },
  { 1, -3, -4, 50, 76, 16, -8, 0 },  { 1, -3, -5, 49, 77, 17, -8, 0 },
  { 1, -3, -5, 48, 77, 18, -8, 0 },  { 1, -3, -5, 47, 77, 19, -8, 0 },
  { 1, -3, -5, 45, 78, 20, -8, 0 },  { 1, -2, -6, 44, 78, 21, -8, 0 },
  { 1, -2, -6, 43, 78, 22, -8, 0 },  { 1, -2, -6, 42, 78, 23, -8, 0 },
  { 1, -2, -7, 41, 79, 24, -8, 0 },  { 1, -2, -7, 40, 79, 25, -8, 0 },
  { 1, -2, -7, 39, 79, 26, -8, 0 },  { 1, -2, -7, 38, 80, 27, -8, -1 },
  { 1, -2, -7, 37, 80, 28, -8, -1 }, { 1, -2, -7, 36, 80, 29, -8, -1 },
  { 1, -1, -8, 35, 80, 30, -8, -1 }, { 1, -1, -8, 34, 80, 31, -8, -1 },
};

// Filters for interpolation (0.75-band) - note this also filters integer pels.
static const InterpKernel filteredinterp_filters750[(1 << RS_SUBPEL_BITS)] = {
  { 2, -11, 25, 96, 25, -11, 2, 0 }, { 2, -11, 24, 96, 26, -11, 2, 0 },
  { 2, -11, 22, 96, 28, -11, 2, 0 }, { 2, -10, 21, 96, 29, -12, 2, 0 },
  { 2, -10, 19, 96, 31, -12, 2, 0 }, { 2, -10, 18, 95, 32, -11, 2, 0 },
  { 2, -10, 17, 95, 34, -12, 2, 0 }, { 2, -9, 15, 95, 35, -12, 2, 0 },
  { 2, -9, 14, 94, 37, -12, 2, 0 },  { 2, -9, 13, 94, 38, -12, 2, 0 },
  { 2, -8, 12, 93, 40, -12, 1, 0 },  { 2, -8, 11, 93, 41, -12, 1, 0 },
  { 2, -8, 9, 92, 43, -12, 1, 1 },   { 2, -8, 8, 92, 44, -12, 1, 1 },
  { 2, -7, 7, 91, 46, -12, 1, 0 },   { 2, -7, 6, 90, 47, -12, 1, 1 },
  { 2, -7, 5, 90, 49, -12, 1, 0 },   { 2, -6, 4, 89, 50, -12, 1, 0 },
  { 2, -6, 3, 88, 52, -12, 0, 1 },   { 2, -6, 2, 87, 54, -12, 0, 1 },
  { 2, -5, 1, 86, 55, -12, 0, 1 },   { 2, -5, 0, 85, 57, -12, 0, 1 },
  { 2, -5, -1, 84, 58, -11, 0, 1 },  { 2, -5, -2, 83, 60, -11, 0, 1 },
  { 2, -4, -2, 82, 61, -11, -1, 1 }, { 1, -4, -3, 81, 63, -10, -1, 1 },
  { 2, -4, -4, 80, 64, -10, -1, 1 }, { 1, -4, -4, 79, 66, -10, -1, 1 },
  { 1, -3, -5, 77, 67, -9, -1, 1 },  { 1, -3, -6, 76, 69, -9, -1, 1 },
  { 1, -3, -6, 75, 70, -8, -2, 1 },  { 1, -2, -7, 74, 71, -8, -2, 1 },
  { 1, -2, -7, 72, 72, -7, -2, 1 },  { 1, -2, -8, 71, 74, -7, -2, 1 },
  { 1, -2, -8, 70, 75, -6, -3, 1 },  { 1, -1, -9, 69, 76, -6, -3, 1 },
  { 1, -1, -9, 67, 77, -5, -3, 1 },  { 1, -1, -10, 66, 79, -4, -4, 1 },
  { 1, -1, -10, 64, 80, -4, -4, 2 }, { 1, -1, -10, 63, 81, -3, -4, 1 },
  { 1, -1, -11, 61, 82, -2, -4, 2 }, { 1, 0, -11, 60, 83, -2, -5, 2 },
  { 1, 0, -11, 58, 84, -1, -5, 2 },  { 1, 0, -12, 57, 85, 0, -5, 2 },
  { 1, 0, -12, 55, 86, 1, -5, 2 },   { 1, 0, -12, 54, 87, 2, -6, 2 },
  { 1, 0, -12, 52, 88, 3, -6, 2 },   { 0, 1, -12, 50, 89, 4, -6, 2 },
  { 0, 1, -12, 49, 90, 5, -7, 2 },   { 1, 1, -12, 47, 90, 6, -7, 2 },
  { 0, 1, -12, 46, 91, 7, -7, 2 },   { 1, 1, -12, 44, 92, 8, -8, 2 },
  { 1, 1, -12, 43, 92, 9, -8, 2 },   { 0, 1, -12, 41, 93, 11, -8, 2 },
  { 0, 1, -12, 40, 93, 12, -8, 2 },  { 0, 2, -12, 38, 94, 13, -9, 2 },
  { 0, 2, -12, 37, 94, 14, -9, 2 },  { 0, 2, -12, 35, 95, 15, -9, 2 },
  { 0, 2, -12, 34, 95, 17, -10, 2 }, { 0, 2, -11, 32, 95, 18, -10, 2 },
  { 0, 2, -12, 31, 96, 19, -10, 2 }, { 0, 2, -12, 29, 96, 21, -10, 2 },
  { 0, 2, -11, 28, 96, 22, -11, 2 }, { 0, 2, -11, 26, 96, 24, -11, 2 },
};

// Filters for interpolation (0.875-band) - note this also filters integer pels.
static const InterpKernel filteredinterp_filters875[(1 << RS_SUBPEL_BITS)] = {
  { 3, -8, 13, 112, 13, -8, 3, 0 },   { 2, -7, 12, 112, 15, -8, 3, -1 },
  { 3, -7, 10, 112, 17, -9, 3, -1 },  { 2, -6, 8, 112, 19, -9, 3, -1 },
  { 2, -6, 7, 112, 21, -10, 3, -1 },  { 2, -5, 6, 111, 22, -10, 3, -1 },
  { 2, -5, 4, 111, 24, -10, 3, -1 },  { 2, -4, 3, 110, 26, -11, 3, -1 },
  { 2, -4, 1, 110, 28, -11, 3, -1 },  { 2, -4, 0, 109, 30, -12, 4, -1 },
  { 1, -3, -1, 108, 32, -12, 4, -1 }, { 1, -3, -2, 108, 34, -13, 4, -1 },
  { 1, -2, -4, 107, 36, -13, 4, -1 }, { 1, -2, -5, 106, 38, -13, 4, -1 },
  { 1, -1, -6, 105, 40, -14, 4, -1 }, { 1, -1, -7, 104, 42, -14, 4, -1 },
  { 1, -1, -7, 103, 44, -15, 4, -1 }, { 1, 0, -8, 101, 46, -15, 4, -1 },
  { 1, 0, -9, 100, 48, -15, 4, -1 },  { 1, 0, -10, 99, 50, -15, 4, -1 },
  { 1, 1, -11, 97, 53, -16, 4, -1 },  { 0, 1, -11, 96, 55, -16, 4, -1 },
  { 0, 1, -12, 95, 57, -16, 4, -1 },  { 0, 2, -13, 93, 59, -16, 4, -1 },
  { 0, 2, -13, 91, 61, -16, 4, -1 },  { 0, 2, -14, 90, 63, -16, 4, -1 },
  { 0, 2, -14, 88, 65, -16, 4, -1 },  { 0, 2, -15, 86, 67, -16, 4, 0 },
  { 0, 3, -15, 84, 69, -17, 4, 0 },   { 0, 3, -16, 83, 71, -17, 4, 0 },
  { 0, 3, -16, 81, 73, -16, 3, 0 },   { 0, 3, -16, 79, 75, -16, 3, 0 },
  { 0, 3, -16, 77, 77, -16, 3, 0 },   { 0, 3, -16, 75, 79, -16, 3, 0 },
  { 0, 3, -16, 73, 81, -16, 3, 0 },   { 0, 4, -17, 71, 83, -16, 3, 0 },
  { 0, 4, -17, 69, 84, -15, 3, 0 },   { 0, 4, -16, 67, 86, -15, 2, 0 },
  { -1, 4, -16, 65, 88, -14, 2, 0 },  { -1, 4, -16, 63, 90, -14, 2, 0 },
  { -1, 4, -16, 61, 91, -13, 2, 0 },  { -1, 4, -16, 59, 93, -13, 2, 0 },
  { -1, 4, -16, 57, 95, -12, 1, 0 },  { -1, 4, -16, 55, 96, -11, 1, 0 },
  { -1, 4, -16, 53, 97, -11, 1, 1 },  { -1, 4, -15, 50, 99, -10, 0, 1 },
  { -1, 4, -15, 48, 100, -9, 0, 1 },  { -1, 4, -15, 46, 101, -8, 0, 1 },
  { -1, 4, -15, 44, 103, -7, -1, 1 }, { -1, 4, -14, 42, 104, -7, -1, 1 },
  { -1, 4, -14, 40, 105, -6, -1, 1 }, { -1, 4, -13, 38, 106, -5, -2, 1 },
  { -1, 4, -13, 36, 107, -4, -2, 1 }, { -1, 4, -13, 34, 108, -2, -3, 1 },
  { -1, 4, -12, 32, 108, -1, -3, 1 }, { -1, 4, -12, 30, 109, 0, -4, 2 },
  { -1, 3, -11, 28, 110, 1, -4, 2 },  { -1, 3, -11, 26, 110, 3, -4, 2 },
  { -1, 3, -10, 24, 111, 4, -5, 2 },  { -1, 3, -10, 22, 111, 6, -5, 2 },
  { -1, 3, -10, 21, 112, 7, -6, 2 },  { -1, 3, -9, 19, 112, 8, -6, 2 },
  { -1, 3, -9, 17, 112, 10, -7, 3 },  { -1, 3, -8, 15, 112, 12, -7, 2 },
};

#define SUBPEL_TAPS_LONG 12
#define FILTER_BITS_LONG 10

// Filters for interpolation (0.875-band)
static const int16_t
    longinterp_filters875[(1 << RS_SUBPEL_BITS)][SUBPEL_TAPS_LONG] = {
      { 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0 },
      { -1, 2, -3, 7, -15, 1023, 16, -8, 5, -3, 2, -1 },
      { -2, 4, -7, 13, -29, 1022, 33, -15, 9, -6, 4, -2 },
      { -3, 6, -11, 20, -43, 1019, 51, -23, 14, -8, 5, -3 },
      { -4, 8, -14, 26, -56, 1016, 68, -31, 19, -11, 7, -4 },
      { -5, 11, -17, 32, -69, 1012, 86, -39, 23, -14, 9, -5 },
      { -6, 12, -21, 38, -81, 1007, 105, -47, 28, -17, 11, -5 },
      { -7, 14, -24, 44, -93, 1001, 124, -55, 33, -19, 12, -6 },
      { -8, 16, -27, 49, -104, 995, 143, -62, 37, -22, 14, -7 },
      { -9, 18, -30, 55, -114, 988, 162, -71, 42, -25, 16, -8 },
      { -10, 20, -33, 60, -124, 980, 182, -78, 46, -28, 18, -9 },
      { -11, 22, -36, 65, -134, 971, 203, -86, 51, -30, 19, -10 },
      { -12, 23, -38, 70, -142, 962, 223, -94, 55, -33, 21, -11 },
      { -12, 25, -41, 74, -151, 952, 244, -101, 59, -35, 22, -12 },
      { -13, 26, -44, 78, -158, 941, 265, -109, 63, -37, 24, -12 },
      { -14, 28, -46, 82, -165, 930, 286, -116, 67, -40, 25, -13 },
      { -15, 29, -48, 86, -172, 918, 307, -123, 71, -42, 27, -14 },
      { -15, 30, -50, 89, -178, 905, 328, -130, 75, -44, 28, -14 },
      { -16, 32, -52, 93, -184, 891, 350, -137, 79, -46, 29, -15 },
      { -16, 33, -54, 96, -188, 877, 371, -144, 82, -48, 31, -16 },
      { -17, 34, -55, 98, -193, 863, 393, -150, 85, -50, 32, -16 },
      { -18, 35, -57, 101, -196, 847, 415, -156, 89, -52, 33, -17 },
      { -18, 36, -58, 103, -200, 832, 436, -162, 92, -54, 34, -17 },
      { -18, 37, -59, 105, -202, 815, 458, -168, 94, -55, 35, -18 },
      { -19, 37, -61, 107, -204, 799, 480, -173, 97, -57, 36, -18 },
      { -19, 38, -61, 108, -206, 781, 502, -178, 99, -58, 36, -18 },
      { -19, 38, -62, 109, -207, 764, 523, -183, 102, -59, 37, -19 },
      { -20, 39, -63, 110, -207, 745, 544, -187, 104, -60, 38, -19 },
      { -20, 39, -63, 110, -207, 727, 566, -191, 105, -61, 38, -19 },
      { -20, 39, -63, 111, -207, 708, 587, -195, 107, -62, 39, -20 },
      { -20, 39, -63, 111, -206, 688, 608, -198, 108, -62, 39, -20 },
      { -20, 39, -63, 111, -205, 669, 628, -200, 109, -63, 39, -20 },
      { -20, 39, -63, 110, -203, 649, 649, -203, 110, -63, 39, -20 },
      { -20, 39, -63, 109, -200, 628, 669, -205, 111, -63, 39, -20 },
      { -20, 39, -62, 108, -198, 608, 688, -206, 111, -63, 39, -20 },
      { -20, 39, -62, 107, -195, 587, 708, -207, 111, -63, 39, -20 },
      { -19, 38, -61, 105, -191, 566, 727, -207, 110, -63, 39, -20 },
      { -19, 38, -60, 104, -187, 544, 745, -207, 110, -63, 39, -20 },
      { -19, 37, -59, 102, -183, 523, 764, -207, 109, -62, 38, -19 },
      { -18, 36, -58, 99, -178, 502, 781, -206, 108, -61, 38, -19 },
      { -18, 36, -57, 97, -173, 480, 799, -204, 107, -61, 37, -19 },
      { -18, 35, -55, 94, -168, 458, 815, -202, 105, -59, 37, -18 },
      { -17, 34, -54, 92, -162, 436, 832, -200, 103, -58, 36, -18 },
      { -17, 33, -52, 89, -156, 415, 847, -196, 101, -57, 35, -18 },
      { -16, 32, -50, 85, -150, 393, 863, -193, 98, -55, 34, -17 },
      { -16, 31, -48, 82, -144, 371, 877, -188, 96, -54, 33, -16 },
      { -15, 29, -46, 79, -137, 350, 891, -184, 93, -52, 32, -16 },
      { -14, 28, -44, 75, -130, 328, 905, -178, 89, -50, 30, -15 },
      { -14, 27, -42, 71, -123, 307, 918, -172, 86, -48, 29, -15 },
      { -13, 25, -40, 67, -116, 286, 930, -165, 82, -46, 28, -14 },
      { -12, 24, -37, 63, -109, 265, 941, -158, 78, -44, 26, -13 },
      { -12, 22, -35, 59, -101, 244, 952, -151, 74, -41, 25, -12 },
      { -11, 21, -33, 55, -94, 223, 962, -142, 70, -38, 23, -12 },
      { -10, 19, -30, 51, -86, 203, 971, -134, 65, -36, 22, -11 },
      { -9, 18, -28, 46, -78, 182, 980, -124, 60, -33, 20, -10 },
      { -8, 16, -25, 42, -71, 162, 988, -114, 55, -30, 18, -9 },
      { -7, 14, -22, 37, -62, 143, 995, -104, 49, -27, 16, -8 },
      { -6, 12, -19, 33, -55, 124, 1001, -93, 44, -24, 14, -7 },
      { -5, 11, -17, 28, -47, 105, 1007, -81, 38, -21, 12, -6 },
      { -5, 9, -14, 23, -39, 86, 1012, -69, 32, -17, 11, -5 },
      { -4, 7, -11, 19, -31, 68, 1016, -56, 26, -14, 8, -4 },
      { -3, 5, -8, 14, -23, 51, 1019, -43, 20, -11, 6, -3 },
      { -2, 4, -6, 9, -15, 33, 1022, -29, 13, -7, 4, -2 },
      { -1, 2, -3, 5, -8, 16, 1023, -15, 7, -3, 2, -1 },
    };

// Filters for interpolation (0.75-band)
static const int16_t
    longinterp_filters750[(1 << RS_SUBPEL_BITS)][SUBPEL_TAPS_LONG] = {
      { 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0 },
      { 0, 1, -2, 5, -14, 1022, 16, -7, 4, -2, 1, 0 },
      { -1, 2, -5, 11, -27, 1020, 33, -14, 7, -4, 2, 0 },
      { -1, 3, -7, 16, -40, 1018, 50, -22, 11, -5, 2, -1 },
      { -1, 4, -9, 21, -53, 1014, 68, -29, 15, -8, 3, -1 },
      { -1, 5, -12, 26, -65, 1009, 86, -37, 19, -9, 4, -1 },
      { -2, 6, -14, 31, -76, 1004, 104, -44, 22, -11, 5, -1 },
      { -2, 7, -16, 35, -87, 998, 123, -51, 26, -13, 6, -2 },
      { -2, 7, -18, 40, -97, 991, 142, -59, 30, -14, 6, -2 },
      { -2, 8, -20, 44, -107, 984, 161, -66, 33, -16, 7, -2 },
      { -3, 9, -22, 48, -116, 975, 181, -73, 37, -18, 8, -2 },
      { -3, 10, -23, 52, -125, 966, 201, -81, 41, -20, 9, -3 },
      { -3, 10, -25, 56, -133, 957, 221, -88, 44, -21, 9, -3 },
      { -3, 11, -27, 60, -141, 946, 242, -95, 47, -23, 10, -3 },
      { -3, 12, -29, 63, -148, 935, 262, -102, 51, -25, 11, -3 },
      { -4, 13, -30, 66, -155, 924, 283, -109, 54, -26, 11, -3 },
      { -4, 13, -31, 69, -161, 911, 304, -115, 57, -28, 12, -3 },
      { -4, 14, -33, 72, -166, 898, 325, -122, 60, -29, 13, -4 },
      { -4, 14, -34, 75, -172, 885, 347, -128, 63, -31, 13, -4 },
      { -4, 15, -36, 77, -176, 871, 368, -135, 66, -32, 14, -4 },
      { -5, 15, -37, 79, -180, 856, 390, -140, 69, -33, 14, -4 },
      { -5, 16, -38, 81, -184, 841, 411, -146, 71, -34, 15, -4 },
      { -5, 16, -38, 83, -186, 825, 432, -152, 74, -35, 15, -5 },
      { -5, 16, -39, 84, -189, 809, 454, -157, 76, -36, 16, -5 },
      { -5, 17, -40, 86, -191, 792, 475, -162, 78, -37, 16, -5 },
      { -5, 17, -41, 87, -192, 774, 497, -166, 80, -38, 16, -5 },
      { -5, 17, -41, 88, -193, 757, 518, -171, 81, -39, 17, -5 },
      { -5, 17, -41, 88, -194, 739, 539, -175, 83, -39, 17, -5 },
      { -5, 17, -42, 89, -194, 720, 560, -178, 85, -40, 17, -5 },
      { -5, 18, -42, 89, -193, 701, 581, -182, 86, -41, 17, -5 },
      { -5, 17, -42, 89, -192, 682, 602, -185, 87, -41, 17, -5 },
      { -5, 18, -42, 89, -191, 662, 622, -187, 88, -42, 17, -5 },
      { -5, 18, -42, 88, -189, 642, 642, -189, 88, -42, 18, -5 },
      { -5, 17, -42, 88, -187, 622, 662, -191, 89, -42, 18, -5 },
      { -5, 17, -41, 87, -185, 602, 682, -192, 89, -42, 17, -5 },
      { -5, 17, -41, 86, -182, 581, 701, -193, 89, -42, 18, -5 },
      { -5, 17, -40, 85, -178, 560, 720, -194, 89, -42, 17, -5 },
      { -5, 17, -39, 83, -175, 539, 739, -194, 88, -41, 17, -5 },
      { -5, 17, -39, 81, -171, 518, 757, -193, 88, -41, 17, -5 },
      { -5, 16, -38, 80, -166, 497, 774, -192, 87, -41, 17, -5 },
      { -5, 16, -37, 78, -162, 475, 792, -191, 86, -40, 17, -5 },
      { -5, 16, -36, 76, -157, 454, 809, -189, 84, -39, 16, -5 },
      { -5, 15, -35, 74, -152, 432, 825, -186, 83, -38, 16, -5 },
      { -4, 15, -34, 71, -146, 411, 841, -184, 81, -38, 16, -5 },
      { -4, 14, -33, 69, -140, 390, 856, -180, 79, -37, 15, -5 },
      { -4, 14, -32, 66, -135, 368, 871, -176, 77, -36, 15, -4 },
      { -4, 13, -31, 63, -128, 347, 885, -172, 75, -34, 14, -4 },
      { -4, 13, -29, 60, -122, 325, 898, -166, 72, -33, 14, -4 },
      { -3, 12, -28, 57, -115, 304, 911, -161, 69, -31, 13, -4 },
      { -3, 11, -26, 54, -109, 283, 924, -155, 66, -30, 13, -4 },
      { -3, 11, -25, 51, -102, 262, 935, -148, 63, -29, 12, -3 },
      { -3, 10, -23, 47, -95, 242, 946, -141, 60, -27, 11, -3 },
      { -3, 9, -21, 44, -88, 221, 957, -133, 56, -25, 10, -3 },
      { -3, 9, -20, 41, -81, 201, 966, -125, 52, -23, 10, -3 },
      { -2, 8, -18, 37, -73, 181, 975, -116, 48, -22, 9, -3 },
      { -2, 7, -16, 33, -66, 161, 984, -107, 44, -20, 8, -2 },
      { -2, 6, -14, 30, -59, 142, 991, -97, 40, -18, 7, -2 },
      { -2, 6, -13, 26, -51, 123, 998, -87, 35, -16, 7, -2 },
      { -1, 5, -11, 22, -44, 104, 1004, -76, 31, -14, 6, -2 },
      { -1, 4, -9, 19, -37, 86, 1009, -65, 26, -12, 5, -1 },
      { -1, 3, -8, 15, -29, 68, 1014, -53, 21, -9, 4, -1 },
      { -1, 2, -5, 11, -22, 50, 1018, -40, 16, -7, 3, -1 },
      { 0, 2, -4, 7, -14, 33, 1020, -27, 11, -5, 2, -1 },
      { 0, 1, -2, 4, -7, 16, 1022, -14, 5, -2, 1, 0 },
    };

// Filters for interpolation (0.625-band)
static const int16_t
    longinterp_filters625[(1 << RS_SUBPEL_BITS)][SUBPEL_TAPS_LONG] = {
      { 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0 },
      { 0, 1, -2, 5, -13, 1022, 16, -7, 3, -1, 0, 0 },
      { 0, 1, -3, 9, -26, 1020, 33, -14, 6, -3, 1, 0 },
      { 0, 2, -5, 13, -38, 1016, 50, -20, 9, -4, 1, 0 },
      { 0, 2, -6, 17, -50, 1012, 68, -27, 12, -5, 1, 0 },
      { 0, 2, -8, 21, -61, 1007, 86, -34, 15, -6, 2, 0 },
      { -1, 3, -9, 25, -71, 1001, 104, -41, 19, -8, 2, 0 },
      { -1, 3, -11, 29, -82, 995, 123, -48, 22, -9, 3, 0 },
      { -1, 4, -12, 33, -91, 988, 141, -55, 25, -10, 3, -1 },
      { -1, 4, -14, 37, -101, 980, 161, -62, 28, -11, 4, -1 },
      { -1, 4, -15, 40, -109, 972, 180, -69, 31, -12, 4, -1 },
      { -1, 5, -16, 43, -117, 962, 200, -76, 34, -13, 4, -1 },
      { -1, 5, -17, 47, -125, 952, 220, -82, 36, -15, 5, -1 },
      { -1, 6, -18, 49, -132, 942, 240, -89, 39, -16, 5, -1 },
      { -1, 6, -20, 52, -139, 931, 261, -95, 42, -17, 5, -1 },
      { -1, 6, -21, 55, -145, 919, 281, -102, 45, -18, 6, -1 },
      { -1, 7, -21, 57, -151, 906, 302, -108, 47, -19, 6, -1 },
      { -1, 7, -23, 60, -156, 893, 323, -114, 50, -20, 6, -1 },
      { -1, 7, -23, 62, -161, 879, 345, -120, 52, -21, 6, -1 },
      { -1, 7, -24, 64, -165, 865, 366, -126, 54, -22, 7, -1 },
      { -1, 8, -25, 65, -169, 850, 387, -132, 57, -22, 7, -1 },
      { -2, 8, -25, 67, -172, 835, 408, -137, 59, -23, 7, -1 },
      { -1, 8, -26, 68, -175, 819, 429, -142, 61, -24, 8, -1 },
      { -2, 8, -27, 70, -177, 803, 451, -147, 63, -25, 8, -1 },
      { -2, 8, -27, 71, -179, 786, 472, -151, 64, -25, 8, -1 },
      { -2, 8, -27, 72, -180, 769, 493, -156, 66, -26, 8, -1 },
      { -1, 9, -28, 72, -181, 751, 514, -160, 67, -26, 8, -1 },
      { -2, 9, -28, 73, -181, 733, 535, -163, 69, -27, 8, -2 },
      { -2, 9, -28, 73, -181, 715, 556, -167, 70, -27, 8, -2 },
      { -2, 9, -28, 73, -181, 696, 577, -170, 71, -28, 9, -2 },
      { -2, 9, -28, 73, -180, 677, 597, -173, 72, -28, 9, -2 },
      { -2, 9, -28, 73, -179, 657, 618, -175, 72, -28, 9, -2 },
      { -2, 9, -28, 73, -177, 637, 637, -177, 73, -28, 9, -2 },
      { -2, 9, -28, 72, -175, 618, 657, -179, 73, -28, 9, -2 },
      { -2, 9, -28, 72, -173, 597, 677, -180, 73, -28, 9, -2 },
      { -2, 9, -28, 71, -170, 577, 696, -181, 73, -28, 9, -2 },
      { -2, 8, -27, 70, -167, 556, 715, -181, 73, -28, 9, -2 },
      { -2, 8, -27, 69, -163, 535, 733, -181, 73, -28, 9, -2 },
      { -1, 8, -26, 67, -160, 514, 751, -181, 72, -28, 9, -1 },
      { -1, 8, -26, 66, -156, 493, 769, -180, 72, -27, 8, -2 },
      { -1, 8, -25, 64, -151, 472, 786, -179, 71, -27, 8, -2 },
      { -1, 8, -25, 63, -147, 451, 803, -177, 70, -27, 8, -2 },
      { -1, 8, -24, 61, -142, 429, 819, -175, 68, -26, 8, -1 },
      { -1, 7, -23, 59, -137, 408, 835, -172, 67, -25, 8, -2 },
      { -1, 7, -22, 57, -132, 387, 850, -169, 65, -25, 8, -1 },
      { -1, 7, -22, 54, -126, 366, 865, -165, 64, -24, 7, -1 },
      { -1, 6, -21, 52, -120, 345, 879, -161, 62, -23, 7, -1 },
      { -1, 6, -20, 50, -114, 323, 893, -156, 60, -23, 7, -1 },
      { -1, 6, -19, 47, -108, 302, 906, -151, 57, -21, 7, -1 },
      { -1, 6, -18, 45, -102, 281, 919, -145, 55, -21, 6, -1 },
      { -1, 5, -17, 42, -95, 261, 931, -139, 52, -20, 6, -1 },
      { -1, 5, -16, 39, -89, 240, 942, -132, 49, -18, 6, -1 },
      { -1, 5, -15, 36, -82, 220, 952, -125, 47, -17, 5, -1 },
      { -1, 4, -13, 34, -76, 200, 962, -117, 43, -16, 5, -1 },
      { -1, 4, -12, 31, -69, 180, 972, -109, 40, -15, 4, -1 },
      { -1, 4, -11, 28, -62, 161, 980, -101, 37, -14, 4, -1 },
      { -1, 3, -10, 25, -55, 141, 988, -91, 33, -12, 4, -1 },
      { 0, 3, -9, 22, -48, 123, 995, -82, 29, -11, 3, -1 },
      { 0, 2, -8, 19, -41, 104, 1001, -71, 25, -9, 3, -1 },
      { 0, 2, -6, 15, -34, 86, 1007, -61, 21, -8, 2, 0 },
      { 0, 1, -5, 12, -27, 68, 1012, -50, 17, -6, 2, 0 },
      { 0, 1, -4, 9, -20, 50, 1016, -38, 13, -5, 2, 0 },
      { 0, 1, -3, 6, -14, 33, 1020, -26, 9, -3, 1, 0 },
      { 0, 0, -1, 3, -7, 16, 1022, -13, 5, -2, 1, 0 },
    };

// Filters for interpolation (0.50-band)
static const int16_t
    longinterp_filters500[(1 << RS_SUBPEL_BITS)][SUBPEL_TAPS_LONG] = {
      { 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0 },
      { 0, 0, -1, 4, -13, 1022, 16, -6, 3, -1, 0, 0 },
      { 0, 0, -2, 8, -24, 1019, 33, -13, 5, -2, 0, 0 },
      { 0, 1, -4, 11, -36, 1015, 50, -19, 8, -3, 1, 0 },
      { 0, 1, -5, 15, -47, 1010, 68, -26, 11, -4, 1, 0 },
      { 0, 1, -6, 18, -57, 1005, 85, -32, 13, -4, 1, 0 },
      { 0, 2, -7, 22, -68, 999, 103, -39, 16, -5, 1, 0 },
      { 0, 2, -8, 25, -77, 993, 122, -46, 18, -6, 1, 0 },
      { 0, 2, -9, 28, -87, 985, 141, -52, 21, -7, 2, 0 },
      { 0, 2, -10, 31, -95, 977, 160, -59, 24, -8, 2, 0 },
      { 0, 2, -11, 34, -103, 968, 180, -65, 26, -9, 2, 0 },
      { 0, 3, -12, 37, -111, 959, 199, -71, 28, -10, 2, 0 },
      { 0, 3, -12, 39, -118, 949, 219, -78, 31, -11, 2, 0 },
      { -1, 3, -13, 42, -125, 938, 239, -84, 33, -11, 3, 0 },
      { 0, 3, -14, 44, -131, 926, 260, -90, 35, -12, 3, 0 },
      { 0, 3, -15, 46, -137, 915, 280, -96, 38, -13, 3, 0 },
      { -1, 4, -15, 49, -143, 902, 301, -102, 40, -13, 3, -1 },
      { -1, 4, -16, 51, -147, 889, 322, -108, 42, -14, 3, -1 },
      { -1, 4, -17, 52, -152, 875, 343, -113, 44, -15, 4, 0 },
      { -1, 4, -17, 54, -156, 861, 364, -119, 46, -15, 4, -1 },
      { -1, 4, -18, 55, -159, 846, 385, -124, 48, -16, 4, 0 },
      { -1, 4, -18, 57, -162, 830, 406, -129, 50, -17, 4, 0 },
      { -1, 5, -19, 58, -165, 815, 427, -134, 51, -17, 4, 0 },
      { -1, 5, -19, 59, -167, 798, 448, -138, 53, -17, 4, -1 },
      { -1, 5, -19, 60, -168, 781, 469, -143, 54, -18, 4, 0 },
      { -1, 5, -20, 61, -170, 764, 490, -147, 56, -18, 5, -1 },
      { -1, 5, -20, 61, -170, 747, 511, -151, 57, -19, 5, -1 },
      { -1, 5, -20, 62, -171, 728, 532, -154, 58, -19, 5, -1 },
      { -1, 5, -20, 62, -171, 710, 552, -157, 59, -19, 5, -1 },
      { -1, 5, -20, 62, -170, 691, 573, -160, 60, -20, 5, -1 },
      { -1, 5, -20, 62, -170, 672, 593, -163, 61, -20, 5, 0 },
      { -1, 5, -20, 62, -168, 653, 613, -165, 61, -20, 5, -1 },
      { -1, 5, -20, 62, -167, 633, 633, -167, 62, -20, 5, -1 },
      { -1, 5, -20, 61, -165, 613, 653, -168, 62, -20, 5, -1 },
      { 0, 5, -20, 61, -163, 593, 672, -170, 62, -20, 5, -1 },
      { -1, 5, -20, 60, -160, 573, 691, -170, 62, -20, 5, -1 },
      { -1, 5, -19, 59, -157, 552, 710, -171, 62, -20, 5, -1 },
      { -1, 5, -19, 58, -154, 532, 728, -171, 62, -20, 5, -1 },
      { -1, 5, -19, 57, -151, 511, 747, -170, 61, -20, 5, -1 },
      { -1, 5, -18, 56, -147, 490, 764, -170, 61, -20, 5, -1 },
      { 0, 4, -18, 54, -143, 469, 781, -168, 60, -19, 5, -1 },
      { -1, 4, -17, 53, -138, 448, 798, -167, 59, -19, 5, -1 },
      { 0, 4, -17, 51, -134, 427, 815, -165, 58, -19, 5, -1 },
      { 0, 4, -17, 50, -129, 406, 830, -162, 57, -18, 4, -1 },
      { 0, 4, -16, 48, -124, 385, 846, -159, 55, -18, 4, -1 },
      { -1, 4, -15, 46, -119, 364, 861, -156, 54, -17, 4, -1 },
      { 0, 4, -15, 44, -113, 343, 875, -152, 52, -17, 4, -1 },
      { -1, 3, -14, 42, -108, 322, 889, -147, 51, -16, 4, -1 },
      { -1, 3, -13, 40, -102, 301, 902, -143, 49, -15, 4, -1 },
      { 0, 3, -13, 38, -96, 280, 915, -137, 46, -15, 3, 0 },
      { 0, 3, -12, 35, -90, 260, 926, -131, 44, -14, 3, 0 },
      { 0, 3, -11, 33, -84, 239, 938, -125, 42, -13, 3, -1 },
      { 0, 2, -11, 31, -78, 219, 949, -118, 39, -12, 3, 0 },
      { 0, 2, -10, 28, -71, 199, 959, -111, 37, -12, 3, 0 },
      { 0, 2, -9, 26, -65, 180, 968, -103, 34, -11, 2, 0 },
      { 0, 2, -8, 24, -59, 160, 977, -95, 31, -10, 2, 0 },
      { 0, 2, -7, 21, -52, 141, 985, -87, 28, -9, 2, 0 },
      { 0, 1, -6, 18, -46, 122, 993, -77, 25, -8, 2, 0 },
      { 0, 1, -5, 16, -39, 103, 999, -68, 22, -7, 2, 0 },
      { 0, 1, -4, 13, -32, 85, 1005, -57, 18, -6, 1, 0 },
      { 0, 1, -4, 11, -26, 68, 1010, -47, 15, -5, 1, 0 },
      { 0, 1, -3, 8, -19, 50, 1015, -36, 11, -4, 1, 0 },
      { 0, 0, -2, 5, -13, 33, 1019, -24, 8, -2, 0, 0 },
      { 0, 0, -1, 3, -6, 16, 1022, -13, 4, -1, 0, 0 },
    };

// Filters for interpolation (Lanczos a=6)
static const int16_t
    longinterp_filterslanczos6[(1 << RS_SUBPEL_BITS)][SUBPEL_TAPS_LONG] = {
      { 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0 },
      { -1, 2, -3, 7, -15, 1024, 15, -7, 3, -2, 1, 0 },
      { -1, 3, -7, 13, -29, 1022, 32, -14, 7, -3, 1, 0 },
      { -2, 5, -10, 19, -43, 1020, 48, -20, 10, -5, 2, 0 },
      { -2, 6, -13, 25, -57, 1017, 65, -27, 14, -7, 3, 0 },
      { -3, 8, -16, 31, -70, 1014, 83, -35, 18, -9, 3, 0 },
      { -3, 9, -19, 37, -82, 1009, 101, -42, 21, -11, 4, 0 },
      { -4, 10, -22, 42, -93, 1003, 119, -49, 25, -12, 5, 0 },
      { -4, 12, -24, 47, -105, 997, 138, -56, 29, -14, 5, -1 },
      { -4, 13, -27, 52, -115, 990, 157, -64, 33, -16, 6, -1 },
      { -5, 14, -29, 57, -125, 982, 176, -71, 36, -18, 7, 0 },
      { -5, 15, -32, 62, -134, 973, 196, -78, 40, -20, 8, -1 },
      { -5, 16, -34, 66, -143, 964, 216, -86, 44, -22, 9, -1 },
      { -6, 17, -36, 70, -151, 954, 237, -93, 47, -24, 10, -1 },
      { -6, 18, -38, 73, -158, 943, 257, -100, 51, -25, 10, -1 },
      { -6, 19, -40, 77, -165, 931, 278, -107, 54, -27, 11, -1 },
      { -6, 19, -41, 80, -171, 919, 299, -114, 58, -29, 12, -2 },
      { -6, 20, -43, 83, -177, 906, 321, -121, 61, -31, 13, -2 },
      { -6, 21, -44, 86, -182, 892, 342, -128, 64, -32, 13, -2 },
      { -6, 21, -45, 88, -187, 878, 364, -134, 67, -34, 14, -2 },
      { -6, 21, -47, 91, -191, 863, 386, -140, 71, -36, 15, -3 },
      { -6, 22, -47, 92, -194, 847, 407, -147, 74, -37, 16, -3 },
      { -6, 22, -48, 94, -197, 831, 429, -152, 77, -39, 16, -3 },
      { -6, 22, -49, 95, -199, 815, 451, -158, 79, -40, 17, -3 },
      { -6, 23, -50, 96, -200, 797, 473, -164, 82, -41, 18, -4 },
      { -6, 23, -50, 97, -201, 780, 495, -169, 84, -43, 18, -4 },
      { -6, 23, -50, 98, -202, 761, 517, -174, 86, -44, 19, -4 },
      { -6, 23, -50, 98, -202, 743, 538, -178, 88, -45, 19, -4 },
      { -6, 23, -50, 98, -202, 724, 560, -182, 90, -46, 20, -5 },
      { -6, 23, -50, 98, -201, 704, 581, -186, 92, -47, 21, -5 },
      { -6, 22, -50, 98, -199, 685, 602, -190, 94, -48, 21, -5 },
      { -5, 22, -49, 97, -198, 664, 623, -193, 95, -48, 21, -5 },
      { -5, 22, -49, 96, -196, 644, 644, -196, 96, -49, 22, -5 },
      { -5, 21, -48, 95, -193, 623, 664, -198, 97, -49, 22, -5 },
      { -5, 21, -48, 94, -190, 602, 685, -199, 98, -50, 22, -6 },
      { -5, 21, -47, 92, -186, 581, 704, -201, 98, -50, 23, -6 },
      { -5, 20, -46, 90, -182, 560, 724, -202, 98, -50, 23, -6 },
      { -4, 19, -45, 88, -178, 538, 743, -202, 98, -50, 23, -6 },
      { -4, 19, -44, 86, -174, 517, 761, -202, 98, -50, 23, -6 },
      { -4, 18, -43, 84, -169, 495, 780, -201, 97, -50, 23, -6 },
      { -4, 18, -41, 82, -164, 473, 797, -200, 96, -50, 23, -6 },
      { -3, 17, -40, 79, -158, 451, 815, -199, 95, -49, 22, -6 },
      { -3, 16, -39, 77, -152, 429, 831, -197, 94, -48, 22, -6 },
      { -3, 16, -37, 74, -147, 407, 847, -194, 92, -47, 22, -6 },
      { -3, 15, -36, 71, -140, 386, 863, -191, 91, -47, 21, -6 },
      { -2, 14, -34, 67, -134, 364, 878, -187, 88, -45, 21, -6 },
      { -2, 13, -32, 64, -128, 342, 892, -182, 86, -44, 21, -6 },
      { -2, 13, -31, 61, -121, 321, 906, -177, 83, -43, 20, -6 },
      { -2, 12, -29, 58, -114, 299, 919, -171, 80, -41, 19, -6 },
      { -1, 11, -27, 54, -107, 278, 931, -165, 77, -40, 19, -6 },
      { -1, 10, -25, 51, -100, 257, 943, -158, 73, -38, 18, -6 },
      { -1, 10, -24, 47, -93, 237, 954, -151, 70, -36, 17, -6 },
      { -1, 9, -22, 44, -86, 216, 964, -143, 66, -34, 16, -5 },
      { -1, 8, -20, 40, -78, 196, 973, -134, 62, -32, 15, -5 },
      { 0, 7, -18, 36, -71, 176, 982, -125, 57, -29, 14, -5 },
      { -1, 6, -16, 33, -64, 157, 990, -115, 52, -27, 13, -4 },
      { -1, 5, -14, 29, -56, 138, 997, -105, 47, -24, 12, -4 },
      { 0, 5, -12, 25, -49, 119, 1003, -93, 42, -22, 10, -4 },
      { 0, 4, -11, 21, -42, 101, 1009, -82, 37, -19, 9, -3 },
      { 0, 3, -9, 18, -35, 83, 1014, -70, 31, -16, 8, -3 },
      { 0, 3, -7, 14, -27, 65, 1017, -57, 25, -13, 6, -2 },
      { 0, 2, -5, 10, -20, 48, 1020, -43, 19, -10, 5, -2 },
      { 0, 1, -3, 7, -14, 32, 1022, -29, 13, -7, 3, -1 },
      { 0, 1, -2, 3, -7, 15, 1024, -15, 7, -3, 2, -1 },
    };

const int16_t av1_resize_filter_normative[(
    1 << RS_SUBPEL_BITS)][UPSCALE_NORMATIVE_TAPS] = {
#if UPSCALE_NORMATIVE_TAPS == 8
  { 0, 0, 0, 128, 0, 0, 0, 0 },        { 0, 0, -1, 128, 2, -1, 0, 0 },
  { 0, 1, -3, 127, 4, -2, 1, 0 },      { 0, 1, -4, 127, 6, -3, 1, 0 },
  { 0, 2, -6, 126, 8, -3, 1, 0 },      { 0, 2, -7, 125, 11, -4, 1, 0 },
  { -1, 2, -8, 125, 13, -5, 2, 0 },    { -1, 3, -9, 124, 15, -6, 2, 0 },
  { -1, 3, -10, 123, 18, -6, 2, -1 },  { -1, 3, -11, 122, 20, -7, 3, -1 },
  { -1, 4, -12, 121, 22, -8, 3, -1 },  { -1, 4, -13, 120, 25, -9, 3, -1 },
  { -1, 4, -14, 118, 28, -9, 3, -1 },  { -1, 4, -15, 117, 30, -10, 4, -1 },
  { -1, 5, -16, 116, 32, -11, 4, -1 }, { -1, 5, -16, 114, 35, -12, 4, -1 },
  { -1, 5, -17, 112, 38, -12, 4, -1 }, { -1, 5, -18, 111, 40, -13, 5, -1 },
  { -1, 5, -18, 109, 43, -14, 5, -1 }, { -1, 6, -19, 107, 45, -14, 5, -1 },
  { -1, 6, -19, 105, 48, -15, 5, -1 }, { -1, 6, -19, 103, 51, -16, 5, -1 },
  { -1, 6, -20, 101, 53, -16, 6, -1 }, { -1, 6, -20, 99, 56, -17, 6, -1 },
  { -1, 6, -20, 97, 58, -17, 6, -1 },  { -1, 6, -20, 95, 61, -18, 6, -1 },
  { -2, 7, -20, 93, 64, -18, 6, -2 },  { -2, 7, -20, 91, 66, -19, 6, -1 },
  { -2, 7, -20, 88, 69, -19, 6, -1 },  { -2, 7, -20, 86, 71, -19, 6, -1 },
  { -2, 7, -20, 84, 74, -20, 7, -2 },  { -2, 7, -20, 81, 76, -20, 7, -1 },
  { -2, 7, -20, 79, 79, -20, 7, -2 },  { -1, 7, -20, 76, 81, -20, 7, -2 },
  { -2, 7, -20, 74, 84, -20, 7, -2 },  { -1, 6, -19, 71, 86, -20, 7, -2 },
  { -1, 6, -19, 69, 88, -20, 7, -2 },  { -1, 6, -19, 66, 91, -20, 7, -2 },
  { -2, 6, -18, 64, 93, -20, 7, -2 },  { -1, 6, -18, 61, 95, -20, 6, -1 },
  { -1, 6, -17, 58, 97, -20, 6, -1 },  { -1, 6, -17, 56, 99, -20, 6, -1 },
  { -1, 6, -16, 53, 101, -20, 6, -1 }, { -1, 5, -16, 51, 103, -19, 6, -1 },
  { -1, 5, -15, 48, 105, -19, 6, -1 }, { -1, 5, -14, 45, 107, -19, 6, -1 },
  { -1, 5, -14, 43, 109, -18, 5, -1 }, { -1, 5, -13, 40, 111, -18, 5, -1 },
  { -1, 4, -12, 38, 112, -17, 5, -1 }, { -1, 4, -12, 35, 114, -16, 5, -1 },
  { -1, 4, -11, 32, 116, -16, 5, -1 }, { -1, 4, -10, 30, 117, -15, 4, -1 },
  { -1, 3, -9, 28, 118, -14, 4, -1 },  { -1, 3, -9, 25, 120, -13, 4, -1 },
  { -1, 3, -8, 22, 121, -12, 4, -1 },  { -1, 3, -7, 20, 122, -11, 3, -1 },
  { -1, 2, -6, 18, 123, -10, 3, -1 },  { 0, 2, -6, 15, 124, -9, 3, -1 },
  { 0, 2, -5, 13, 125, -8, 2, -1 },    { 0, 1, -4, 11, 125, -7, 2, 0 },
  { 0, 1, -3, 8, 126, -6, 2, 0 },      { 0, 1, -3, 6, 127, -4, 1, 0 },
  { 0, 1, -2, 4, 127, -3, 1, 0 },      { 0, 0, -1, 2, 128, -1, 0, 0 },
#else
#error "Invalid value of UPSCALE_NORMATIVE_TAPS"
#endif  // UPSCALE_NORMATIVE_TAPS == 8
};

// Filters for interpolation (full-band) - no filtering for integer pixels
#define filteredinterp_filters1000 av1_resize_filter_normative

// Filters for factor of 2 downsampling.
static const int16_t av1_down2_symeven_half_filter[] = { 56, 12, -3, -1 };
static const int16_t av1_down2_symodd_half_filter[] = { 64, 35, 0, -3 };

static const int16_t *choose_interp_filter(int in_length, int out_length,
                                           int longfilt, int *subpel_taps,
                                           int *filter_bits) {
  const int out_length16 = out_length * 16;
  (void)longinterp_filterslanczos6;
  (void)longinterp_filters875;
  (void)longinterp_filters750;
  (void)longinterp_filters625;
  (void)longinterp_filters500;
  if (longfilt) {
    *subpel_taps = SUBPEL_TAPS_LONG;
    *filter_bits = FILTER_BITS_LONG;
    if (out_length16 >= in_length * 13)
      return longinterp_filters875[0];
    else if (out_length16 >= in_length * 11)
      return longinterp_filters750[0];
    else if (out_length16 >= in_length * 9)
      return longinterp_filters625[0];
    else
      return longinterp_filters500[0];
  } else {
    *subpel_taps = SUBPEL_TAPS;
    *filter_bits = FILTER_BITS;
    if (out_length16 >= in_length * 16)
      return filteredinterp_filters1000[0];
    else if (out_length16 >= in_length * 13)
      return filteredinterp_filters875[0];
    else if (out_length16 >= in_length * 11)
      return filteredinterp_filters750[0];
    else if (out_length16 >= in_length * 9)
      return filteredinterp_filters625[0];
    else
      return filteredinterp_filters500[0];
  }
}

static void interpolate_core(const uint8_t *const input, int in_length,
                             uint8_t *output, int out_length,
                             const int16_t *interp_filters, int interp_taps,
                             int filter_bits) {
  const int32_t delta =
      (((uint32_t)in_length << RS_SCALE_SUBPEL_BITS) + out_length / 2) /
      out_length;
  const int32_t offset =
      in_length > out_length
          ? (((int32_t)(in_length - out_length) << (RS_SCALE_SUBPEL_BITS - 1)) +
             out_length / 2) /
                out_length
          : -(((int32_t)(out_length - in_length)
               << (RS_SCALE_SUBPEL_BITS - 1)) +
              out_length / 2) /
                out_length;
  uint8_t *optr = output;
  int x, x1, x2, sum, k, int_pel, sub_pel;
  int32_t y;

  x = 0;
  y = offset + RS_SCALE_EXTRA_OFF;
  while ((y >> RS_SCALE_SUBPEL_BITS) < (interp_taps / 2 - 1)) {
    x++;
    y += delta;
  }
  x1 = x;
  x = out_length - 1;
  y = delta * x + offset + RS_SCALE_EXTRA_OFF;
  while ((y >> RS_SCALE_SUBPEL_BITS) + (int32_t)(interp_taps / 2) >=
         in_length) {
    x--;
    y -= delta;
  }
  x2 = x;
  if (x1 > x2) {
    for (x = 0, y = offset + RS_SCALE_EXTRA_OFF; x < out_length;
         ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k) {
        const int pk = int_pel - interp_taps / 2 + 1 + k;
        sum += filter[k] * input[AOMMAX(AOMMIN(pk, in_length - 1), 0)];
      }
      *optr++ = clip_pixel(ROUND_POWER_OF_TWO(sum, filter_bits));
    }
  } else {
    // Initial part.
    for (x = 0, y = offset + RS_SCALE_EXTRA_OFF; x < x1; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] * input[AOMMAX(int_pel - interp_taps / 2 + 1 + k, 0)];
      *optr++ = clip_pixel(ROUND_POWER_OF_TWO(sum, filter_bits));
    }
    // Middle part.
    for (; x <= x2; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] * input[int_pel - interp_taps / 2 + 1 + k];
      *optr++ = clip_pixel(ROUND_POWER_OF_TWO(sum, filter_bits));
    }
    // End part.
    for (; x < out_length; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] *
               input[AOMMIN(int_pel - interp_taps / 2 + 1 + k, in_length - 1)];
      *optr++ = clip_pixel(ROUND_POWER_OF_TWO(sum, filter_bits));
    }
  }
}

static void interpolate_core_double_prec(const double *const input,
                                         int in_length, double *output,
                                         int out_length,
                                         const int16_t *interp_filters,
                                         int interp_taps, int filter_bits) {
  const int32_t delta =
      (((uint32_t)in_length << RS_SCALE_SUBPEL_BITS) + out_length / 2) /
      out_length;
  const int32_t offset =
      in_length > out_length
          ? (((int32_t)(in_length - out_length) << (RS_SCALE_SUBPEL_BITS - 1)) +
             out_length / 2) /
                out_length
          : -(((int32_t)(out_length - in_length)
               << (RS_SCALE_SUBPEL_BITS - 1)) +
              out_length / 2) /
                out_length;
  double *optr = output;
  int x, x1, x2, k, int_pel, sub_pel;
  double sum;
  int32_t y;

  x = 0;
  y = offset + RS_SCALE_EXTRA_OFF;
  while ((y >> RS_SCALE_SUBPEL_BITS) < (interp_taps / 2 - 1)) {
    x++;
    y += delta;
  }
  x1 = x;
  x = out_length - 1;
  y = delta * x + offset + RS_SCALE_EXTRA_OFF;
  while ((y >> RS_SCALE_SUBPEL_BITS) + (int32_t)(interp_taps / 2) >=
         in_length) {
    x--;
    y -= delta;
  }
  x2 = x;
  if (x1 > x2) {
    for (x = 0, y = offset + RS_SCALE_EXTRA_OFF; x < out_length;
         ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k) {
        const int pk = int_pel - interp_taps / 2 + 1 + k;
        sum += filter[k] * input[AOMMAX(AOMMIN(pk, in_length - 1), 0)];
      }
      *optr++ = sum / (1 << filter_bits);
    }
  } else {
    // Initial part.
    for (x = 0, y = offset + RS_SCALE_EXTRA_OFF; x < x1; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] * input[AOMMAX(int_pel - interp_taps / 2 + 1 + k, 0)];
      *optr++ = sum / (1 << filter_bits);
    }
    // Middle part.
    for (; x <= x2; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] * input[int_pel - interp_taps / 2 + 1 + k];
      *optr++ = sum / (1 << filter_bits);
    }
    // End part.
    for (; x < out_length; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] *
               input[AOMMIN(int_pel - interp_taps / 2 + 1 + k, in_length - 1)];
      *optr++ = sum / (1 << filter_bits);
    }
  }
}

static void interpolate(const uint8_t *const input, int in_length,
                        uint8_t *output, int out_length, int longfilt) {
  int subpel_taps;
  int filter_bits;
  const int16_t *interp_filters = choose_interp_filter(
      in_length, out_length, longfilt, &subpel_taps, &filter_bits);

  interpolate_core(input, in_length, output, out_length, interp_filters,
                   subpel_taps, filter_bits);
}

static void interpolate_double_prec(const double *const input, int in_length,
                                    double *output, int out_length,
                                    int longfilt) {
  int subpel_taps;
  int filter_bits;
  const int16_t *interp_filters = choose_interp_filter(
      in_length, out_length, longfilt, &subpel_taps, &filter_bits);

  interpolate_core_double_prec(input, in_length, output, out_length,
                               interp_filters, subpel_taps, filter_bits);
}

int32_t av1_get_upscale_convolve_step(int in_length, int out_length) {
  return ((in_length << RS_SCALE_SUBPEL_BITS) + out_length / 2) / out_length;
}

static int32_t get_upscale_convolve_x0(int in_length, int out_length,
                                       int32_t x_step_qn) {
  const int err = out_length * x_step_qn - (in_length << RS_SCALE_SUBPEL_BITS);
  const int32_t x0 =
      (-((out_length - in_length) << (RS_SCALE_SUBPEL_BITS - 1)) +
       out_length / 2) /
          out_length +
      RS_SCALE_EXTRA_OFF - err / 2;
  return (int32_t)((uint32_t)x0 & RS_SCALE_SUBPEL_MASK);
}

static void down2_symeven(const uint8_t *const input, int length,
                          uint8_t *output) {
  // Actual filter len = 2 * filter_len_half.
  const int16_t *filter = av1_down2_symeven_half_filter;
  const int filter_len_half = sizeof(av1_down2_symeven_half_filter) / 2;
  int i, j;
  uint8_t *optr = output;
  int l1 = filter_len_half;
  int l2 = (length - filter_len_half);
  l1 += (l1 & 1);
  l2 += (l2 & 1);
  if (l1 > l2) {
    // Short input length.
    for (i = 0; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum +=
            (input[AOMMAX(i - j, 0)] + input[AOMMIN(i + 1 + j, length - 1)]) *
            filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
  } else {
    // Initial part.
    for (i = 0; i < l1; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum += (input[AOMMAX(i - j, 0)] + input[i + 1 + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
    // Middle part.
    for (; i < l2; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[i + 1 + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
    // End part.
    for (; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum +=
            (input[i - j] + input[AOMMIN(i + 1 + j, length - 1)]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
  }
}

static void down2_symodd(const uint8_t *const input, int length,
                         uint8_t *output) {
  // Actual filter len = 2 * filter_len_half - 1.
  const int16_t *filter = av1_down2_symodd_half_filter;
  const int filter_len_half = sizeof(av1_down2_symodd_half_filter) / 2;
  int i, j;
  uint8_t *optr = output;
  int l1 = filter_len_half - 1;
  int l2 = (length - filter_len_half + 1);
  l1 += (l1 & 1);
  l2 += (l2 & 1);
  if (l1 > l2) {
    // Short input length.
    for (i = 0; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[(i - j < 0 ? 0 : i - j)] +
                input[(i + j >= length ? length - 1 : i + j)]) *
               filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
  } else {
    // Initial part.
    for (i = 0; i < l1; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[(i - j < 0 ? 0 : i - j)] + input[i + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
    // Middle part.
    for (; i < l2; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[i + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
    // End part.
    for (; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[(i + j >= length ? length - 1 : i + j)]) *
               filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel(sum);
    }
  }
}

static int get_down2_length(int length, int steps) {
  for (int s = 0; s < steps; ++s) length = (length + 1) >> 1;
  return length;
}

static int get_down2_steps(int in_length, int out_length) {
  int steps = 0;
  int proj_in_length;
  while ((proj_in_length = get_down2_length(in_length, 1)) >= out_length) {
    ++steps;
    in_length = proj_in_length;
    if (in_length == 1) {
      // Special case: we break because any further calls to get_down2_length()
      // with be with length == 1, which return 1, resulting in an infinite
      // loop.
      break;
    }
  }
  return steps;
}

static void resize_multistep(const uint8_t *const input, int length,
                             uint8_t *output, int olength, uint8_t *otmp,
                             int longfilt) {
  if (length == olength) {
    memcpy(output, input, sizeof(output[0]) * length);
    return;
  }
  const int steps = get_down2_steps(length, olength);

  if (steps > 0) {
    uint8_t *out = NULL;
    int filteredlength = length;

    assert(otmp != NULL);
    uint8_t *otmp2 = otmp + get_down2_length(length, 1);
    for (int s = 0; s < steps; ++s) {
      const int proj_filteredlength = get_down2_length(filteredlength, 1);
      const uint8_t *const in = (s == 0 ? input : out);
      if (s == steps - 1 && proj_filteredlength == olength)
        out = output;
      else
        out = (s & 1 ? otmp2 : otmp);
      if (filteredlength & 1)
        down2_symodd(in, filteredlength, out);
      else
        down2_symeven(in, filteredlength, out);
      filteredlength = proj_filteredlength;
    }
    if (filteredlength != olength) {
      interpolate(out, filteredlength, output, olength, longfilt);
    }
  } else {
    interpolate(input, length, output, olength, longfilt);
  }
}

static void upscale_multistep_double_prec(const double *const input, int length,
                                          double *output, int olength,
                                          int longfilt) {
  assert(length <= olength);
  interpolate_double_prec(input, length, output, olength, longfilt);
}

static void fill_col_to_arr(uint8_t *img, int stride, int len, uint8_t *arr) {
  int i;
  uint8_t *iptr = img;
  uint8_t *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *aptr++ = *iptr;
  }
}

static void fill_arr_to_col(uint8_t *img, int stride, int len, uint8_t *arr) {
  int i;
  uint8_t *iptr = img;
  uint8_t *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *iptr = *aptr++;
  }
}

static void fill_col_to_arr_double_prec(double *img, int stride, int len,
                                        double *arr) {
  int i;
  double *iptr = img;
  double *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *aptr++ = *iptr;
  }
}

static void fill_arr_to_col_double_prec(double *img, int stride, int len,
                                        double *arr) {
  int i;
  double *iptr = img;
  double *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *iptr = *aptr++;
  }
}

void av1_resize_plane(const uint8_t *const input, int height, int width,
                      int in_stride, uint8_t *output, int height2, int width2,
                      int out_stride) {
  const int longfilt = 1;
  int i;
  uint8_t *intbuf = (uint8_t *)aom_malloc(sizeof(uint8_t) * width2 * height);
  uint8_t *tmpbuf =
      (uint8_t *)aom_malloc(sizeof(uint8_t) * AOMMAX(width, height));
  uint8_t *arrbuf = (uint8_t *)aom_malloc(sizeof(uint8_t) * height);
  uint8_t *arrbuf2 = (uint8_t *)aom_malloc(sizeof(uint8_t) * height2);
  if (intbuf == NULL || tmpbuf == NULL || arrbuf == NULL || arrbuf2 == NULL)
    goto Error;
  assert(width > 0);
  assert(height > 0);
  assert(width2 > 0);
  assert(height2 > 0);
  if (height == height2) {
    // horizontal only resizing
    for (i = 0; i < height; ++i)
      resize_multistep(input + in_stride * i, width, output + out_stride * i,
                       width2, tmpbuf, longfilt);
  } else {
    for (i = 0; i < height; ++i)
      resize_multistep(input + in_stride * i, width, intbuf + width2 * i,
                       width2, tmpbuf, longfilt);
    for (i = 0; i < width2; ++i) {
      fill_col_to_arr(intbuf + i, width2, height, arrbuf);
      resize_multistep(arrbuf, height, arrbuf2, height2, tmpbuf, longfilt);
      fill_arr_to_col(output + i, out_stride, height2, arrbuf2);
    }
  }

Error:
  aom_free(intbuf);
  aom_free(tmpbuf);
  aom_free(arrbuf);
  aom_free(arrbuf2);
}

void av1_upscale_plane_double_prec(const double *const input, int height,
                                   int width, int in_stride, double *output,
                                   int height2, int width2, int out_stride) {
  int i;
  double *intbuf = (double *)aom_malloc(sizeof(double) * width2 * height);
  double *arrbuf = (double *)aom_malloc(sizeof(double) * height);
  double *arrbuf2 = (double *)aom_malloc(sizeof(double) * height2);
  if (intbuf == NULL || arrbuf == NULL || arrbuf2 == NULL) goto Error;
  assert(width > 0);
  assert(height > 0);
  assert(width2 > 0);
  assert(height2 > 0);
  for (i = 0; i < height; ++i)
    upscale_multistep_double_prec(input + in_stride * i, width,
                                  intbuf + width2 * i, width2, 0);
  for (i = 0; i < width2; ++i) {
    fill_col_to_arr_double_prec(intbuf + i, width2, height, arrbuf);
    upscale_multistep_double_prec(arrbuf, height, arrbuf2, height2, 0);
    fill_arr_to_col_double_prec(output + i, out_stride, height2, arrbuf2);
  }

Error:
  aom_free(intbuf);
  aom_free(arrbuf);
  aom_free(arrbuf2);
}

static void upscale_normative_rect(const uint8_t *const input, int height,
                                   int width, int in_stride, uint8_t *output,
                                   int height2, int width2, int out_stride,
                                   int x_step_qn, int x0_qn, int pad_left,
                                   int pad_right) {
  assert(width > 0);
  assert(height > 0);
  assert(width2 > 0);
  assert(height2 > 0);
  assert(height2 == height);

  // Extend the left/right pixels of the tile column if needed
  // (either because we can't sample from other tiles, or because we're at
  // a frame edge).
  // Save the overwritten pixels into tmp_left and tmp_right.
  // Note: Because we pass input-1 to av1_convolve_horiz_rs, we need one extra
  // column of border pixels compared to what we'd naively think.
  const int border_cols = UPSCALE_NORMATIVE_TAPS / 2 + 1;
  uint8_t *tmp_left =
      NULL;  // Silence spurious "may be used uninitialized" warnings
  uint8_t *tmp_right = NULL;
  uint8_t *const in_tl = (uint8_t *)(input - border_cols);  // Cast off 'const'
  uint8_t *const in_tr = (uint8_t *)(input + width);
  if (pad_left) {
    tmp_left = (uint8_t *)aom_malloc(sizeof(*tmp_left) * border_cols * height);
    for (int i = 0; i < height; i++) {
      memcpy(tmp_left + i * border_cols, in_tl + i * in_stride, border_cols);
      memset(in_tl + i * in_stride, input[i * in_stride], border_cols);
    }
  }
  if (pad_right) {
    tmp_right =
        (uint8_t *)aom_malloc(sizeof(*tmp_right) * border_cols * height);
    for (int i = 0; i < height; i++) {
      memcpy(tmp_right + i * border_cols, in_tr + i * in_stride, border_cols);
      memset(in_tr + i * in_stride, input[i * in_stride + width - 1],
             border_cols);
    }
  }

  av1_convolve_horiz_rs(input - 1, in_stride, output, out_stride, width2,
                        height2, &av1_resize_filter_normative[0][0], x0_qn,
                        x_step_qn);

  // Restore the left/right border pixels
  if (pad_left) {
    for (int i = 0; i < height; i++) {
      memcpy(in_tl + i * in_stride, tmp_left + i * border_cols, border_cols);
    }
    aom_free(tmp_left);
  }
  if (pad_right) {
    for (int i = 0; i < height; i++) {
      memcpy(in_tr + i * in_stride, tmp_right + i * border_cols, border_cols);
    }
    aom_free(tmp_right);
  }
}

static void highbd_interpolate_core(const uint16_t *const input, int in_length,
                                    uint16_t *output, int out_length, int bd,
                                    const int16_t *interp_filters,
                                    int interp_taps, int filter_bits) {
  const int32_t delta =
      (((uint32_t)in_length << RS_SCALE_SUBPEL_BITS) + out_length / 2) /
      out_length;
  const int32_t offset =
      in_length > out_length
          ? (((int32_t)(in_length - out_length) << (RS_SCALE_SUBPEL_BITS - 1)) +
             out_length / 2) /
                out_length
          : -(((int32_t)(out_length - in_length)
               << (RS_SCALE_SUBPEL_BITS - 1)) +
              out_length / 2) /
                out_length;
  uint16_t *optr = output;
  int x, x1, x2, sum, k, int_pel, sub_pel;
  int32_t y;

  x = 0;
  y = offset + RS_SCALE_EXTRA_OFF;
  while ((y >> RS_SCALE_SUBPEL_BITS) < (interp_taps / 2 - 1)) {
    x++;
    y += delta;
  }
  x1 = x;
  x = out_length - 1;
  y = delta * x + offset + RS_SCALE_EXTRA_OFF;
  while ((y >> RS_SCALE_SUBPEL_BITS) + (int32_t)(interp_taps / 2) >=
         in_length) {
    x--;
    y -= delta;
  }
  x2 = x;
  if (x1 > x2) {
    for (x = 0, y = offset + RS_SCALE_EXTRA_OFF; x < out_length;
         ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k) {
        const int pk = int_pel - interp_taps / 2 + 1 + k;
        sum += filter[k] * input[AOMMAX(AOMMIN(pk, in_length - 1), 0)];
      }
      *optr++ = clip_pixel_highbd(ROUND_POWER_OF_TWO(sum, filter_bits), bd);
    }
  } else {
    // Initial part.
    for (x = 0, y = offset + RS_SCALE_EXTRA_OFF; x < x1; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] * input[AOMMAX(int_pel - interp_taps / 2 + 1 + k, 0)];
      *optr++ = clip_pixel_highbd(ROUND_POWER_OF_TWO(sum, filter_bits), bd);
    }
    // Middle part.
    for (; x <= x2; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] * input[int_pel - interp_taps / 2 + 1 + k];
      *optr++ = clip_pixel_highbd(ROUND_POWER_OF_TWO(sum, filter_bits), bd);
    }
    // End part.
    for (; x < out_length; ++x, y += delta) {
      int_pel = y >> RS_SCALE_SUBPEL_BITS;
      sub_pel = (y >> RS_SCALE_EXTRA_BITS) & RS_SUBPEL_MASK;
      const int16_t *filter = &interp_filters[sub_pel * interp_taps];
      sum = 0;
      for (k = 0; k < interp_taps; ++k)
        sum += filter[k] *
               input[AOMMIN(int_pel - interp_taps / 2 + 1 + k, in_length - 1)];
      *optr++ = clip_pixel_highbd(ROUND_POWER_OF_TWO(sum, filter_bits), bd);
    }
  }
}

static void highbd_interpolate(const uint16_t *const input, int in_length,
                               uint16_t *output, int out_length, int bd,
                               int longfilt) {
  int subpel_taps;
  int filter_bits;
  const int16_t *interp_filters = choose_interp_filter(
      in_length, out_length, longfilt, &subpel_taps, &filter_bits);

  highbd_interpolate_core(input, in_length, output, out_length, bd,
                          interp_filters, subpel_taps, filter_bits);
}

static void highbd_down2_symeven(const uint16_t *const input, int length,
                                 uint16_t *output, int bd) {
  // Actual filter len = 2 * filter_len_half.
  static const int16_t *filter = av1_down2_symeven_half_filter;
  const int filter_len_half = sizeof(av1_down2_symeven_half_filter) / 2;
  int i, j;
  uint16_t *optr = output;
  int l1 = filter_len_half;
  int l2 = (length - filter_len_half);
  l1 += (l1 & 1);
  l2 += (l2 & 1);
  if (l1 > l2) {
    // Short input length.
    for (i = 0; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum +=
            (input[AOMMAX(0, i - j)] + input[AOMMIN(i + 1 + j, length - 1)]) *
            filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
  } else {
    // Initial part.
    for (i = 0; i < l1; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum += (input[AOMMAX(0, i - j)] + input[i + 1 + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
    // Middle part.
    for (; i < l2; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[i + 1 + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
    // End part.
    for (; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1));
      for (j = 0; j < filter_len_half; ++j) {
        sum +=
            (input[i - j] + input[AOMMIN(i + 1 + j, length - 1)]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
  }
}

static void highbd_down2_symodd(const uint16_t *const input, int length,
                                uint16_t *output, int bd) {
  // Actual filter len = 2 * filter_len_half - 1.
  static const int16_t *filter = av1_down2_symodd_half_filter;
  const int filter_len_half = sizeof(av1_down2_symodd_half_filter) / 2;
  int i, j;
  uint16_t *optr = output;
  int l1 = filter_len_half - 1;
  int l2 = (length - filter_len_half + 1);
  l1 += (l1 & 1);
  l2 += (l2 & 1);
  if (l1 > l2) {
    // Short input length.
    for (i = 0; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[AOMMAX(i - j, 0)] + input[AOMMIN(i + j, length - 1)]) *
               filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
  } else {
    // Initial part.
    for (i = 0; i < l1; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[AOMMAX(i - j, 0)] + input[i + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
    // Middle part.
    for (; i < l2; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[i + j]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
    // End part.
    for (; i < length; i += 2) {
      int sum = (1 << (FILTER_BITS - 1)) + input[i] * filter[0];
      for (j = 1; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[AOMMIN(i + j, length - 1)]) * filter[j];
      }
      sum >>= FILTER_BITS;
      *optr++ = clip_pixel_highbd(sum, bd);
    }
  }
}

static void highbd_resize_multistep(const uint16_t *const input, int length,
                                    uint16_t *output, int olength,
                                    uint16_t *otmp, int bd, int longfilt) {
  if (length == olength) {
    memcpy(output, input, sizeof(output[0]) * length);
    return;
  }
  const int steps = get_down2_steps(length, olength);

  if (steps > 0) {
    uint16_t *out = NULL;
    int filteredlength = length;

    assert(otmp != NULL);
    uint16_t *otmp2 = otmp + get_down2_length(length, 1);
    for (int s = 0; s < steps; ++s) {
      const int proj_filteredlength = get_down2_length(filteredlength, 1);
      const uint16_t *const in = (s == 0 ? input : out);
      if (s == steps - 1 && proj_filteredlength == olength)
        out = output;
      else
        out = (s & 1 ? otmp2 : otmp);
      if (filteredlength & 1)
        highbd_down2_symodd(in, filteredlength, out, bd);
      else
        highbd_down2_symeven(in, filteredlength, out, bd);
      filteredlength = proj_filteredlength;
    }
    if (filteredlength != olength) {
      highbd_interpolate(out, filteredlength, output, olength, bd, longfilt);
    }
  } else {
    highbd_interpolate(input, length, output, olength, bd, longfilt);
  }
}

static void highbd_fill_col_to_arr(uint16_t *img, int stride, int len,
                                   uint16_t *arr) {
  int i;
  uint16_t *iptr = img;
  uint16_t *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *aptr++ = *iptr;
  }
}

static void highbd_fill_arr_to_col(uint16_t *img, int stride, int len,
                                   uint16_t *arr) {
  int i;
  uint16_t *iptr = img;
  uint16_t *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *iptr = *aptr++;
  }
}

void av1_highbd_resize_plane(const uint8_t *const input, int height, int width,
                             int in_stride, uint8_t *output, int height2,
                             int width2, int out_stride, int bd) {
  const int longfilt = 1;
  int i;
  uint16_t *intbuf = (uint16_t *)aom_malloc(sizeof(uint16_t) * width2 * height);
  uint16_t *tmpbuf =
      (uint16_t *)aom_malloc(sizeof(uint16_t) * AOMMAX(width, height));
  uint16_t *arrbuf = (uint16_t *)aom_malloc(sizeof(uint16_t) * height);
  uint16_t *arrbuf2 = (uint16_t *)aom_malloc(sizeof(uint16_t) * height2);
  if (intbuf == NULL || tmpbuf == NULL || arrbuf == NULL || arrbuf2 == NULL)
    goto Error;
  if (height == height2) {
    // horizontal only resizing
    for (i = 0; i < height; ++i)
      highbd_resize_multistep(CONVERT_TO_SHORTPTR(input + in_stride * i), width,
                              CONVERT_TO_SHORTPTR(output + out_stride * i),
                              width2, tmpbuf, bd, longfilt);
  } else {
    for (i = 0; i < height; ++i) {
      highbd_resize_multistep(CONVERT_TO_SHORTPTR(input + in_stride * i), width,
                              intbuf + width2 * i, width2, tmpbuf, bd,
                              longfilt);
    }
    for (i = 0; i < width2; ++i) {
      highbd_fill_col_to_arr(intbuf + i, width2, height, arrbuf);
      highbd_resize_multistep(arrbuf, height, arrbuf2, height2, tmpbuf, bd,
                              longfilt);
      highbd_fill_arr_to_col(CONVERT_TO_SHORTPTR(output + i), out_stride,
                             height2, arrbuf2);
    }
  }

Error:
  aom_free(intbuf);
  aom_free(tmpbuf);
  aom_free(arrbuf);
  aom_free(arrbuf2);
}

static void highbd_upscale_normative_rect(const uint8_t *const input,
                                          int height, int width, int in_stride,
                                          uint8_t *output, int height2,
                                          int width2, int out_stride,
                                          int x_step_qn, int x0_qn,
                                          int pad_left, int pad_right, int bd) {
  assert(width > 0);
  assert(height > 0);
  assert(width2 > 0);
  assert(height2 > 0);
  assert(height2 == height);

  // Extend the left/right pixels of the tile column if needed
  // (either because we can't sample from other tiles, or because we're at
  // a frame edge).
  // Save the overwritten pixels into tmp_left and tmp_right.
  // Note: Because we pass input-1 to av1_convolve_horiz_rs, we need one extra
  // column of border pixels compared to what we'd naively think.
  const int border_cols = UPSCALE_NORMATIVE_TAPS / 2 + 1;
  const int border_size = border_cols * sizeof(uint16_t);
  uint16_t *tmp_left =
      NULL;  // Silence spurious "may be used uninitialized" warnings
  uint16_t *tmp_right = NULL;
  uint16_t *const input16 = CONVERT_TO_SHORTPTR(input);
  uint16_t *const in_tl = input16 - border_cols;
  uint16_t *const in_tr = input16 + width;
  if (pad_left) {
    tmp_left = (uint16_t *)aom_malloc(sizeof(*tmp_left) * border_cols * height);
    for (int i = 0; i < height; i++) {
      memcpy(tmp_left + i * border_cols, in_tl + i * in_stride, border_size);
      aom_memset16(in_tl + i * in_stride, input16[i * in_stride], border_cols);
    }
  }
  if (pad_right) {
    tmp_right =
        (uint16_t *)aom_malloc(sizeof(*tmp_right) * border_cols * height);
    for (int i = 0; i < height; i++) {
      memcpy(tmp_right + i * border_cols, in_tr + i * in_stride, border_size);
      aom_memset16(in_tr + i * in_stride, input16[i * in_stride + width - 1],
                   border_cols);
    }
  }

  av1_highbd_convolve_horiz_rs(CONVERT_TO_SHORTPTR(input - 1), in_stride,
                               CONVERT_TO_SHORTPTR(output), out_stride, width2,
                               height2, &av1_resize_filter_normative[0][0],
                               x0_qn, x_step_qn, bd);

  // Restore the left/right border pixels
  if (pad_left) {
    for (int i = 0; i < height; i++) {
      memcpy(in_tl + i * in_stride, tmp_left + i * border_cols, border_size);
    }
    aom_free(tmp_left);
  }
  if (pad_right) {
    for (int i = 0; i < height; i++) {
      memcpy(in_tr + i * in_stride, tmp_right + i * border_cols, border_size);
    }
    aom_free(tmp_right);
  }
}

void av1_resize_frame420(const uint8_t *const y, int y_stride,
                         const uint8_t *const u, const uint8_t *const v,
                         int uv_stride, int height, int width, uint8_t *oy,
                         int oy_stride, uint8_t *ou, uint8_t *ov,
                         int ouv_stride, int oheight, int owidth) {
  av1_resize_plane(y, height, width, y_stride, oy, oheight, owidth, oy_stride);
  av1_resize_plane(u, height / 2, width / 2, uv_stride, ou, oheight / 2,
                   owidth / 2, ouv_stride);
  av1_resize_plane(v, height / 2, width / 2, uv_stride, ov, oheight / 2,
                   owidth / 2, ouv_stride);
}

void av1_resize_frame422(const uint8_t *const y, int y_stride,
                         const uint8_t *const u, const uint8_t *const v,
                         int uv_stride, int height, int width, uint8_t *oy,
                         int oy_stride, uint8_t *ou, uint8_t *ov,
                         int ouv_stride, int oheight, int owidth) {
  av1_resize_plane(y, height, width, y_stride, oy, oheight, owidth, oy_stride);
  av1_resize_plane(u, height, width / 2, uv_stride, ou, oheight, owidth / 2,
                   ouv_stride);
  av1_resize_plane(v, height, width / 2, uv_stride, ov, oheight, owidth / 2,
                   ouv_stride);
}

void av1_resize_frame444(const uint8_t *const y, int y_stride,
                         const uint8_t *const u, const uint8_t *const v,
                         int uv_stride, int height, int width, uint8_t *oy,
                         int oy_stride, uint8_t *ou, uint8_t *ov,
                         int ouv_stride, int oheight, int owidth) {
  av1_resize_plane(y, height, width, y_stride, oy, oheight, owidth, oy_stride);
  av1_resize_plane(u, height, width, uv_stride, ou, oheight, owidth,
                   ouv_stride);
  av1_resize_plane(v, height, width, uv_stride, ov, oheight, owidth,
                   ouv_stride);
}

void av1_highbd_resize_frame420(const uint8_t *const y, int y_stride,
                                const uint8_t *const u, const uint8_t *const v,
                                int uv_stride, int height, int width,
                                uint8_t *oy, int oy_stride, uint8_t *ou,
                                uint8_t *ov, int ouv_stride, int oheight,
                                int owidth, int bd) {
  av1_highbd_resize_plane(y, height, width, y_stride, oy, oheight, owidth,
                          oy_stride, bd);
  av1_highbd_resize_plane(u, height / 2, width / 2, uv_stride, ou, oheight / 2,
                          owidth / 2, ouv_stride, bd);
  av1_highbd_resize_plane(v, height / 2, width / 2, uv_stride, ov, oheight / 2,
                          owidth / 2, ouv_stride, bd);
}

void av1_highbd_resize_frame422(const uint8_t *const y, int y_stride,
                                const uint8_t *const u, const uint8_t *const v,
                                int uv_stride, int height, int width,
                                uint8_t *oy, int oy_stride, uint8_t *ou,
                                uint8_t *ov, int ouv_stride, int oheight,
                                int owidth, int bd) {
  av1_highbd_resize_plane(y, height, width, y_stride, oy, oheight, owidth,
                          oy_stride, bd);
  av1_highbd_resize_plane(u, height, width / 2, uv_stride, ou, oheight,
                          owidth / 2, ouv_stride, bd);
  av1_highbd_resize_plane(v, height, width / 2, uv_stride, ov, oheight,
                          owidth / 2, ouv_stride, bd);
}

void av1_highbd_resize_frame444(const uint8_t *const y, int y_stride,
                                const uint8_t *const u, const uint8_t *const v,
                                int uv_stride, int height, int width,
                                uint8_t *oy, int oy_stride, uint8_t *ou,
                                uint8_t *ov, int ouv_stride, int oheight,
                                int owidth, int bd) {
  av1_highbd_resize_plane(y, height, width, y_stride, oy, oheight, owidth,
                          oy_stride, bd);
  av1_highbd_resize_plane(u, height, width, uv_stride, ou, oheight, owidth,
                          ouv_stride, bd);
  av1_highbd_resize_plane(v, height, width, uv_stride, ov, oheight, owidth,
                          ouv_stride, bd);
}

void av1_resize_and_extend_frame(const YV12_BUFFER_CONFIG *src,
                                 YV12_BUFFER_CONFIG *dst, int bd,
                                 const int num_planes) {
  // TODO(dkovalev): replace YV12_BUFFER_CONFIG with aom_image_t

  // We use AOMMIN(num_planes, MAX_MB_PLANE) instead of num_planes to quiet
  // the static analysis warnings.
  for (int i = 0; i < AOMMIN(num_planes, MAX_MB_PLANE); ++i) {
    const int is_uv = i > 0;
    if (src->flags & YV12_FLAG_HIGHBITDEPTH)
      av1_highbd_resize_plane(src->buffers[i], src->crop_heights[is_uv],
                              src->crop_widths[is_uv], src->strides[is_uv],
                              dst->buffers[i], dst->crop_heights[is_uv],
                              dst->crop_widths[is_uv], dst->strides[is_uv], bd);
    else
      av1_resize_plane(src->buffers[i], src->crop_heights[is_uv],
                       src->crop_widths[is_uv], src->strides[is_uv],
                       dst->buffers[i], dst->crop_heights[is_uv],
                       dst->crop_widths[is_uv], dst->strides[is_uv]);
  }
  aom_extend_frame_borders(dst, num_planes);
}

void av1_upscale_normative_rows(const AV1_COMMON *cm, const uint8_t *src,
                                int src_stride, uint8_t *dst, int dst_stride,
                                int plane, int rows) {
  const int is_uv = (plane > 0);
  const int ss_x = is_uv && cm->seq_params.subsampling_x;
  const int downscaled_plane_width = ROUND_POWER_OF_TWO(cm->width, ss_x);
  const int upscaled_plane_width =
      ROUND_POWER_OF_TWO(cm->superres_upscaled_width, ss_x);
  const int superres_denom = cm->superres_scale_denominator;

  TileInfo tile_col;
  const int32_t x_step_qn = av1_get_upscale_convolve_step(
      downscaled_plane_width, upscaled_plane_width);
  int32_t x0_qn = get_upscale_convolve_x0(downscaled_plane_width,
                                          upscaled_plane_width, x_step_qn);

  for (int j = 0; j < cm->tile_cols; j++) {
    av1_tile_set_col(&tile_col, cm, j);
    // Determine the limits of this tile column in both the source
    // and destination images.
    // Note: The actual location which we start sampling from is
    // (downscaled_x0 - 1 + (x0_qn/2^14)), and this quantity increases
    // by exactly dst_width * (x_step_qn/2^14) pixels each iteration.
    const int downscaled_x0 = tile_col.mi_col_start << (MI_SIZE_LOG2 - ss_x);
    const int downscaled_x1 = tile_col.mi_col_end << (MI_SIZE_LOG2 - ss_x);
    const int src_width = downscaled_x1 - downscaled_x0;

    const int upscaled_x0 = (downscaled_x0 * superres_denom) / SCALE_NUMERATOR;
    int upscaled_x1;
    if (j == cm->tile_cols - 1) {
      // Note that we can't just use AOMMIN here - due to rounding,
      // (downscaled_x1 * superres_denom) / SCALE_NUMERATOR may be less than
      // upscaled_plane_width.
      upscaled_x1 = upscaled_plane_width;
    } else {
      upscaled_x1 = (downscaled_x1 * superres_denom) / SCALE_NUMERATOR;
    }

    const uint8_t *const src_ptr = src + downscaled_x0;
    uint8_t *const dst_ptr = dst + upscaled_x0;
    const int dst_width = upscaled_x1 - upscaled_x0;

    const int pad_left = (j == 0);
    const int pad_right = (j == cm->tile_cols - 1);

    if (cm->seq_params.use_highbitdepth)
      highbd_upscale_normative_rect(src_ptr, rows, src_width, src_stride,
                                    dst_ptr, rows, dst_width, dst_stride,
                                    x_step_qn, x0_qn, pad_left, pad_right,
                                    cm->seq_params.bit_depth);
    else
      upscale_normative_rect(src_ptr, rows, src_width, src_stride, dst_ptr,
                             rows, dst_width, dst_stride, x_step_qn, x0_qn,
                             pad_left, pad_right);

    // Update the fractional pixel offset to prepare for the next tile column.
    x0_qn += (dst_width * x_step_qn) - (src_width << RS_SCALE_SUBPEL_BITS);
  }
}

void av1_upscale_normative_and_extend_frame(const AV1_COMMON *cm,
                                            const YV12_BUFFER_CONFIG *src,
                                            YV12_BUFFER_CONFIG *dst) {
  const int num_planes = av1_num_planes(cm);
  for (int i = 0; i < num_planes; ++i) {
    const int is_uv = (i > 0);
    av1_upscale_normative_rows(cm, src->buffers[i], src->strides[is_uv],
                               dst->buffers[i], dst->strides[is_uv], i,
                               src->crop_heights[is_uv]);
  }

  aom_extend_frame_borders(dst, num_planes);
}

YV12_BUFFER_CONFIG *av1_scale_if_required(AV1_COMMON *cm,
                                          YV12_BUFFER_CONFIG *unscaled,
                                          YV12_BUFFER_CONFIG *scaled) {
  const int num_planes = av1_num_planes(cm);
  if (cm->width != unscaled->y_crop_width ||
      cm->height != unscaled->y_crop_height) {
    av1_resize_and_extend_frame(unscaled, scaled, (int)cm->seq_params.bit_depth,
                                num_planes);
    return scaled;
  } else {
    return unscaled;
  }
}

// Calculates the scaled dimension given the original dimension and the scale
// denominator.
static void calculate_scaled_size_helper(int *dim, int denom) {
  if (denom != SCALE_NUMERATOR) {
    // We need to ensure the constraint in "Appendix A" of the spec:
    // * FrameWidth is greater than or equal to 16
    // * FrameHeight is greater than or equal to 16
    // For this, we clamp the downscaled dimension to at least 16. One
    // exception: if original dimension itself was < 16, then we keep the
    // downscaled dimension to be same as the original, to ensure that resizing
    // is valid.
    const int min_dim = AOMMIN(16, *dim);
    // Use this version if we need *dim to be even
    // *width = (*width * SCALE_NUMERATOR + denom) / (2 * denom);
    // *width <<= 1;
    *dim = (*dim * SCALE_NUMERATOR + denom / 2) / (denom);
    *dim = AOMMAX(*dim, min_dim);
  }
}

void av1_calculate_scaled_size(int *width, int *height, int resize_denom) {
  calculate_scaled_size_helper(width, resize_denom);
  calculate_scaled_size_helper(height, resize_denom);
}

void av1_calculate_scaled_superres_size(int *width, int *height,
                                        int superres_denom) {
  (void)height;
  calculate_scaled_size_helper(width, superres_denom);
}

void av1_calculate_unscaled_superres_size(int *width, int *height, int denom) {
  if (denom != SCALE_NUMERATOR) {
    // Note: av1_calculate_scaled_superres_size() rounds *up* after division
    // when the resulting dimensions are odd. So here, we round *down*.
    *width = *width * denom / SCALE_NUMERATOR;
    (void)height;
  }
}

// Copy only the config data from 'src' to 'dst'.
static void copy_buffer_config(const YV12_BUFFER_CONFIG *const src,
                               YV12_BUFFER_CONFIG *const dst) {
  dst->bit_depth = src->bit_depth;
  dst->color_primaries = src->color_primaries;
  dst->transfer_characteristics = src->transfer_characteristics;
  dst->matrix_coefficients = src->matrix_coefficients;
  dst->monochrome = src->monochrome;
  dst->chroma_sample_position = src->chroma_sample_position;
  dst->color_range = src->color_range;
}

// TODO(afergs): Look for in-place upscaling
// TODO(afergs): aom_ vs av1_ functions? Which can I use?
// Upscale decoded image.
void av1_superres_upscale(AV1_COMMON *cm, BufferPool *const pool) {
  const int num_planes = av1_num_planes(cm);
  if (!av1_superres_scaled(cm)) return;
  const SequenceHeader *const seq_params = &cm->seq_params;

  YV12_BUFFER_CONFIG copy_buffer;
  memset(&copy_buffer, 0, sizeof(copy_buffer));

  YV12_BUFFER_CONFIG *const frame_to_show = &cm->cur_frame->buf;

  const int aligned_width = ALIGN_POWER_OF_TWO(cm->width, 3);
  if (aom_alloc_frame_buffer(
          &copy_buffer, aligned_width, cm->height, seq_params->subsampling_x,
          seq_params->subsampling_y, seq_params->use_highbitdepth,
          AOM_BORDER_IN_PIXELS, cm->byte_alignment))
    aom_internal_error(&cm->error, AOM_CODEC_MEM_ERROR,
                       "Failed to allocate copy buffer for superres upscaling");

  // Copy function assumes the frames are the same size.
  // Note that it does not copy YV12_BUFFER_CONFIG config data.
  aom_yv12_copy_frame(frame_to_show, &copy_buffer, num_planes);

  assert(copy_buffer.y_crop_width == aligned_width);
  assert(copy_buffer.y_crop_height == cm->height);

  // Realloc the current frame buffer at a higher resolution in place.
  if (pool != NULL) {
    // Use callbacks if on the decoder.
    aom_codec_frame_buffer_t *fb = &cm->cur_frame->raw_frame_buffer;
    aom_release_frame_buffer_cb_fn_t release_fb_cb = pool->release_fb_cb;
    aom_get_frame_buffer_cb_fn_t cb = pool->get_fb_cb;
    void *cb_priv = pool->cb_priv;

    lock_buffer_pool(pool);
    // Realloc with callback does not release the frame buffer - release first.
    if (release_fb_cb(cb_priv, fb)) {
      unlock_buffer_pool(pool);
      aom_internal_error(
          &cm->error, AOM_CODEC_MEM_ERROR,
          "Failed to free current frame buffer before superres upscaling");
    }
    // aom_realloc_frame_buffer() leaves config data for frame_to_show intact
    if (aom_realloc_frame_buffer(
            frame_to_show, cm->superres_upscaled_width,
            cm->superres_upscaled_height, seq_params->subsampling_x,
            seq_params->subsampling_y, seq_params->use_highbitdepth,
            AOM_BORDER_IN_PIXELS, cm->byte_alignment, fb, cb, cb_priv)) {
      unlock_buffer_pool(pool);
      aom_internal_error(
          &cm->error, AOM_CODEC_MEM_ERROR,
          "Failed to allocate current frame buffer for superres upscaling");
    }
    unlock_buffer_pool(pool);
  } else {
    // Make a copy of the config data for frame_to_show in copy_buffer
    copy_buffer_config(frame_to_show, &copy_buffer);

    // Don't use callbacks on the encoder.
    // aom_alloc_frame_buffer() clears the config data for frame_to_show
    if (aom_alloc_frame_buffer(
            frame_to_show, cm->superres_upscaled_width,
            cm->superres_upscaled_height, seq_params->subsampling_x,
            seq_params->subsampling_y, seq_params->use_highbitdepth,
            AOM_BORDER_IN_PIXELS, cm->byte_alignment))
      aom_internal_error(
          &cm->error, AOM_CODEC_MEM_ERROR,
          "Failed to reallocate current frame buffer for superres upscaling");

    // Restore config data back to frame_to_show
    copy_buffer_config(&copy_buffer, frame_to_show);
  }
  // TODO(afergs): verify frame_to_show is correct after realloc
  //               encoder:
  //               decoder:

  assert(frame_to_show->y_crop_width == cm->superres_upscaled_width);
  assert(frame_to_show->y_crop_height == cm->superres_upscaled_height);

  // Scale up and back into frame_to_show.
  assert(frame_to_show->y_crop_width != cm->width);
  av1_upscale_normative_and_extend_frame(cm, &copy_buffer, frame_to_show);

  // Free the copy buffer
  aom_free_frame_buffer(&copy_buffer);
}

#if CONFIG_SUPERRES_TX64 || CONFIG_DSPL_RESIDUAL
static void down2_symeven_signed(const int16_t *const input, int length,
                                 int16_t *output, const int16_t *filter,
                                 int filter_length, int downbits, int doclip,
                                 int bd) {
  assert((length & 1) == 0);
  assert((filter_length & 1) == 0);
  const int filter_len_half = filter_length >> 1;
  int i, j;
  int16_t *optr = output;
  int l1 = filter_len_half;
  int l2 = (length - filter_len_half);
  l1 += (l1 & 1);
  l2 += (l2 & 1);
  if (l1 > l2) {
    // Short input length.
    for (i = 0; i < length; i += 2) {
      int32_t sum = 0;
      for (j = 0; j < filter_len_half; ++j) {
        sum +=
            (input[AOMMAX(0, i - j)] + input[AOMMIN(i + 1 + j, length - 1)]) *
            filter[j + filter_len_half];
      }
      sum = ROUND_POWER_OF_TWO_SIGNED(sum, downbits);
      *optr++ = doclip ? clip_pixel_signed(sum, bd) : sum;
    }
  } else {
    // Initial part.
    for (i = 0; i < l1; i += 2) {
      int32_t sum = 0;
      for (j = 0; j < filter_len_half; ++j) {
        sum += (input[AOMMAX(0, i - j)] + input[i + 1 + j]) *
               filter[j + filter_len_half];
      }
      sum = ROUND_POWER_OF_TWO_SIGNED(sum, downbits);
      *optr++ = doclip ? clip_pixel_signed(sum, bd) : sum;
    }
    // Middle part.
    for (; i < l2; i += 2) {
      int32_t sum = 0;
      for (j = 0; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[i + 1 + j]) * filter[j + filter_len_half];
      }
      sum = ROUND_POWER_OF_TWO_SIGNED(sum, downbits);
      *optr++ = doclip ? clip_pixel_signed(sum, bd) : sum;
    }
    // End part.
    for (; i < length; i += 2) {
      int32_t sum = 0;
      for (j = 0; j < filter_len_half; ++j) {
        sum += (input[i - j] + input[AOMMIN(i + 1 + j, length - 1)]) *
               filter[j + filter_len_half];
      }
      sum = ROUND_POWER_OF_TWO_SIGNED(sum, downbits);
      *optr++ = doclip ? clip_pixel_signed(sum, bd) : sum;
    }
  }
}

// Note the filter below is for 3/4 offset interpolation. The 1/4 offset
// is derived from that by flipping.
static void up2_symeven_signed(const int16_t *const input, int length,
                               int16_t *output, const int16_t *filter,
                               int filter_length, int downbits, int doclip,
                               int bd) {
  assert((filter_length & 1) == 0);
  const int filter_len_half = filter_length >> 1;
  int16_t *optr = output;
  for (int i = 0; i < length; ++i) {
    int32_t sum = 0;
    for (int j = 0; j < filter_length; ++j) {
      const int k = AOMMAX(AOMMIN(i - filter_len_half + j, length - 1), 0);
      sum += input[k] * filter[j];
    }
    sum = ROUND_POWER_OF_TWO_SIGNED(sum, downbits);
    *optr++ = doclip ? clip_pixel_signed(sum, bd) : sum;

    sum = 0;
    for (int j = 0; j < filter_length; ++j) {
      const int k = AOMMAX(AOMMIN(i - filter_len_half + 1 + j, length - 1), 0);
      sum += input[k] * filter[filter_length - 1 - j];
    }
    sum = ROUND_POWER_OF_TWO_SIGNED(sum, downbits);
    *optr++ = doclip ? clip_pixel_signed(sum, bd) : sum;
  }
}

static void signed_fill_col_to_arr(int16_t *img, int stride, int len,
                                   int16_t *arr) {
  int i;
  int16_t *iptr = img;
  int16_t *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *aptr++ = *iptr;
  }
}

static void signed_fill_arr_to_col(int16_t *img, int stride, int len,
                                   int16_t *arr) {
  int i;
  int16_t *iptr = img;
  int16_t *aptr = arr;
  for (i = 0; i < len; ++i, iptr += stride) {
    *iptr = *aptr++;
  }
}

// Note tmp buffer otmp must be at least the length of the input
static void signed_down2_multistep(const int16_t *const input, int length,
                                   int16_t *output, int steps, int16_t *otmp,
                                   int num_phases, int final_phase, int bd) {
  const int16_t filter_prec = 10;
  const int16_t filter[] = {
    // Lanczos a = 6 centered downsampling kernel
    // -1,  -3,   6,  10, -14, -21,  29,  40, -57, -86, 150, 459,
    // 459, 150, -86, -57,  40,  29, -21, -14,  10,   6,  -3,  -1,

    // Lanczos a = 3 centered downsampling kernel
    4, 15, -35, -68, 139, 457, 457, 139, -68, -35, 15, 4,

    // Lanczos a = 2 centered downsampling kernel
    // -9, -43, 119, 445, 445, 119, -43,  -9,
  };
  const int filter_len = sizeof(filter) / sizeof(filter[0]);
  const int downbits = num_phases == 2
                           ? (final_phase ? filter_prec + 2 : filter_prec - 2)
                           : filter_prec;

  assert((length & ((1 << steps) - 1)) == 0);
  if (steps == 0) {
    memcpy(output, input, sizeof(output[0]) * length);
    return;
  }
  int16_t *out = NULL;
  int filteredlength = length;
  assert(otmp != NULL);
  int16_t *otmp2 = otmp + (length >> 1);
  for (int s = 0; s < steps; ++s) {
    const int proj_filteredlength = (filteredlength >> 1);
    const int16_t *const in = (s == 0 ? input : out);
    if (s == steps - 1)
      out = output;
    else
      out = (s & 1 ? otmp2 : otmp);
    down2_symeven_signed(in, filteredlength, out, filter, filter_len, downbits,
                         final_phase, bd);
    filteredlength = proj_filteredlength;
  }
  assert(filteredlength == (length >> steps));
}

// Note tmp buffer otmp must be at least the length of the output
static void signed_up2_multistep(const int16_t *const input, int length,
                                 int16_t *output, int steps, int16_t *otmp,
                                 int num_phases, int final_phase, int bd) {
  const int16_t filter_prec = 10;
  // Enter the centered upsmpling filter kernel for 3/4 phase.
  // Note the other 1/4 phase kernel needed for centered upsampling
  // is the flipped version of this filter.
  const int16_t filter[] = {
    // Lanczos a = 8 upsampling kernel for 3/4 phase.
    // -1,    6,  -14,   25,  -41,   68, -122,  303,
    // 920, -177,   90,  -53,   32,  -19,   10,   -3,

    // Lanczos a = 6 upsampling kernel for 3/4 phase.
    -2, 12, -29, 58, -114, 299, 919, -171, 80, -41, 19, -6,

    // Lanczos a = 4 upsampling kernel for 3/4 phase.
    // -4,   32,  -94,  289,  915, -156,   57,  -15,
  };
  const int filter_len = sizeof(filter) / sizeof(filter[0]);
  const int downbits = num_phases == 2
                           ? (final_phase ? filter_prec + 2 : filter_prec - 2)
                           : filter_prec;

  if (steps == 0) {
    memcpy(output, input, sizeof(output[0]) * length);
    return;
  }
  const int olength = length << steps;
  int16_t *out = NULL;
  int filteredlength = length;
  assert(otmp != NULL);
  int16_t *otmp2 = otmp + (olength >> 1);
  for (int s = 0; s < steps; ++s) {
    const int proj_filteredlength = (filteredlength << 1);
    const int16_t *const in = (s == 0 ? input : out);
    if (s == steps - 1)
      out = output;
    else
      out = (s & 1 ? otmp2 : otmp);
    up2_symeven_signed(in, filteredlength, out, filter, filter_len, downbits,
                       final_phase, bd);
    filteredlength = proj_filteredlength;
  }
  assert(filteredlength == (length << steps));
}

void av1_signed_down2(const int16_t *const input, int height, int width,
                      int in_stride, int16_t *output, int out_stride,
                      int stepsh, int stepsw, int bd) {
  const int width2 = width >> stepsw;
  const int height2 = height >> stepsh;
  int i;
  int16_t *intbuf = (int16_t *)aom_malloc(sizeof(int16_t) * width2 * height);
  int16_t *tmpbuf =
      (int16_t *)aom_malloc(sizeof(int16_t) * AOMMAX(width, height));
  int16_t *arrbuf = (int16_t *)aom_malloc(sizeof(int16_t) * height);
  int16_t *arrbuf2 = (int16_t *)aom_malloc(sizeof(int16_t) * height2);
  if (intbuf == NULL || tmpbuf == NULL || arrbuf == NULL || arrbuf2 == NULL)
    goto Error;

  const int num_phases = (stepsw && stepsh) ? 2 : 1;
  for (i = 0; i < height; ++i) {
    signed_down2_multistep(input + in_stride * i, width, intbuf + width2 * i,
                           stepsw, tmpbuf, num_phases, num_phases == 1, bd);
  }
  for (i = 0; i < width2; ++i) {
    signed_fill_col_to_arr(intbuf + i, width2, height, arrbuf);
    signed_down2_multistep(arrbuf, height, arrbuf2, stepsh, tmpbuf, num_phases,
                           1, bd);
    signed_fill_arr_to_col(output + i, out_stride, height2, arrbuf2);
  }

Error:
  aom_free(intbuf);
  aom_free(tmpbuf);
  aom_free(arrbuf);
  aom_free(arrbuf2);
}

void av1_signed_up2(const int16_t *const input, int height, int width,
                    int in_stride, int16_t *output, int out_stride, int stepsh,
                    int stepsw, int bd) {
  const int width2 = width << stepsw;
  const int height2 = height << stepsh;
  int i;
  int16_t *intbuf = (int16_t *)aom_malloc(sizeof(int16_t) * width2 * height);
  int16_t *tmpbuf =
      (int16_t *)aom_malloc(sizeof(int16_t) * AOMMAX(width, height));
  int16_t *arrbuf = (int16_t *)aom_malloc(sizeof(int16_t) * height);
  int16_t *arrbuf2 = (int16_t *)aom_malloc(sizeof(int16_t) * height2);
  if (intbuf == NULL || tmpbuf == NULL || arrbuf == NULL || arrbuf2 == NULL)
    goto Error;
  const int num_phases = (stepsw && stepsh) ? 2 : 1;
  for (i = 0; i < height; ++i) {
    signed_up2_multistep(input + in_stride * i, width, intbuf + width2 * i,
                         stepsw, tmpbuf, num_phases, num_phases == 1, bd);
  }
  for (i = 0; i < width2; ++i) {
    signed_fill_col_to_arr(intbuf + i, width2, height, arrbuf);
    signed_up2_multistep(arrbuf, height, arrbuf2, stepsh, tmpbuf, num_phases, 1,
                         bd);
    signed_fill_arr_to_col(output + i, out_stride, height2, arrbuf2);
  }

Error:
  aom_free(intbuf);
  aom_free(tmpbuf);
  aom_free(arrbuf);
  aom_free(arrbuf2);
}
#endif  // CONFIG_SUPERRES_TX64 || CONFIG_DSPL_RESIDUAL
